\newcommand\zz[1]{\texttt{#1}}

Much of the work of a software engineers is to build the software they produce.
There is much automation to engineer in managing versions and branches,
regression testing, performance tests, dependency management, and, packaging.
Familiar tools to be managed by engineers include \matteo{supply urlrefs}
\zz{git}, \zz{maven}, \zz{jazz}, \zz{junit}. And, much in common to these is a
rule based inference engine, such as that of \zz{make}, \zz{maven}, and
\zz{gradle}. Reasoning about and working with these tools requires a different
way of thinking than that of the declarative, object oriented, functional, and
even aspect-oriented paradigms

Our interest here is in the programming paradigm behind these way of thinking.
Concretely, \Reap is a programming language under design whose main constructs
resemble underlying concepts of these building systems. In \zz{make} for
example, these concepts include basics such as ‟target”, ‟recipe”, and
‟Makefile”, and more advanced such as ‟default rule”, ‟variable” and ‟nested
Makefile”. Note that these concepts are not unique to \zz{make}. They are
fundamental, under different names sometimes, in other sofware build tools. 

Development of \Reap begun we started when realized that the semi-declarative,
semi-procedural paradigm behind inference engines, is applicable in the domain
of managing user interaction, specifically, the development of an Eclipse
plugin. This manuscript describes it as a general purpose programming language. 

Currently, \Reap is at an early design stage, and for this reason, this
manuscript is also a call for comments, questions, and thoughts. \Reap has no
compiler yet. To run a program in \Reap, the program must to be manually
transliterated to \Java. This is not difficult since \Reap is a DSL extension
of \Java, and borrows \Java's  syntax, most concretely, $λ$-expressions.
Semantics is also similar, except within an \emph{environment}, the \Reap
reificication of a Makefile, semantics is different than that of a \Java class,
even though an environment may syntactically resemble a class containing
functions and methods.

% vim:: /\/\//,/^\s*}/- !awk -F // '{printf "\%-20s //\%s\n", $1, $2}'
\begin{reap}
££.Time {££ // Time environment
  Integer h 9;       // Hours, defaults to 9
  Integer m 11;      // Minutes, defaults to 11
  Integer s;         // Seconds, defaults to £$⊥$£
}
\end{reap}


Remove the "=" sign in initialization but not assignment.
% vim:: /\/\//,/^\s*}/- !awk -F // '{printf "\%-20s //\%s\n", $1, $2}'
\begin{java}
class Time extends Object {££// Time environment transliterated to \Java
  Integer h = 9;     // Hours, initially set to £$\cc{9}$£
  Integer m = 11;    // Minutes, initially set to £$\cc{11}$£
  Integer s;         // Seconds, initially set to £$\kk{null}$£
} 
\end{java}

\begin{reap}
££.Time.toString {££
  String ¢ = h + ":" + m + ":" + s;
}
\end{reap}
reaches fields directly, just like inheritance.

\begin{java}
class toString extends Time {££ // £\Java£ transliteration of $\cc{Time.toString}$
  String ¢() ->  h + ":" + m + ":" + s;
} 
\end{java}

\begin{java}
class Time {££ // More accurate £\Java£ transliteration of $\cc{Time.toString}$
  public static class toString extends Time {££
    String ¢() {££
       h + ":" + m + ":" + s;
    }
  }
} 
\end{java}

\begin{reap}
££.Time.AMPM {££
  Boolean isAM super.h < 12;
  Boolean isPM ££!isAM;
  String ampm isAM ££? "AM" : "PM";
  String h super.h - (isAM ££? 0 : 12);
}
\end{reap}

\begin{reap}
££.Time.fraction {££
  Real hour 24 * 60;
  Real ¢() -> ((60*h + m) + s)/24./60 ;
}
\end{reap}
reads as
\begin{java}
/** £\Java£ transliteration of £\cc{.Time.fraction}£
*/
class fraction extends Time {££ 
  double hour() {££ return  24 * 60; }
  double ¢() {££ return ((60*h + m) + s)/hour; }
}
\end{java}
or so
\begin{java}
/* more efficient £\Java£ transliteration of £\cc{.Time.fraction}£
**/
class fraction extends Time {££ 
  double ¢() {££ return ((60*h + m) + s)/(double) (24*60) ; }
}
\end{java}

\begin{java}
class Time {££
  static class AMPM extends Time {££ /* £$⋯$ £*/ }
  static class fraction extends Time {££ /* £$⋯$ £*/}
}
\end{java}

\matteo{read about mixins and traits.start with mixins}

\begin{reap}
££.Time.AMPM.fraction;
\end{reap}

\begin{java}
class Time {££
  static class AMPM extends Time {££
    /* £$⋯$ £*/
    static class fraction extends Time {££ /* £$⋯$ £*/}
  }
  static class fraction extends Time {££ /* £$⋯$ £*/}
}
\end{java}

\begin{reap}
££.Time.fraction.AMPM;
\end{reap}

\begin{java}
class Time {££
  static class AMPM extends Time {££
    /** £$⋯$£*/
    static class fraction extends Time {££ /* £$⋯$ £*/}
  }
  static class fraction extends Time {££
    /** £$⋯$£*/
    static class AMPM extends fraction {££ /* £$⋯$ £*/}
  }
}
\end{java}

\begin{reap}
££.Time.GuessSeconds {££ // A function to set the number of seconds to 0
  Integer s 0;
} 
\end{reap}

\begin{reap}
££.Math {££ // Global math constants 
  Real E   2.7182818284590452354;
  Real PI  3.14159265358979323846;
  Real PI2() -> 2 * PI; 
}
\end{reap}


\begin{reap}
££.Math.Sin0 {££ // A function to compute£~$\sin(x)$£ //
  Real £\_£;
  Real positive() -> £\_£ > 0 ££? £\_£ : -£\_£;
  Real cycles() -> (int)(positive() / PI2);
  Real normalized() -> positive - PI2 * cycles;
  Real ¢() -> normalized;
}
\end{reap}

\begin{reap}
££.Math.Sin1 {££ // A function to compute£~$\sin(x)$£ //
  Real £\_£;
  Real ¢() -> super.normalized
}
\end{reap}


Whenever a property is undefined it is like a function that throws an exception.
Any time you use it, the called would also be throwing an exception.
\begin{reap}
££.Time.fraction {££
  Real ¢() -> ((60*h + m) + s)/24./60 ;
}
\end{reap}
To evaluate
\begin{java}
  ((60*h + m) + s)/24./60
\end{java}
replace~$h→9, m→11, s→⊥$
to obtain

{\scriptsize
\begin{equation}
\begin{split}
  ¢ & = ((60·9 + 11) + ⊥)/24./60⏎
  & = ((540 + 11) + ⊥)/24./60⏎
  & = (551 + ⊥)/1440. &⏎
  & = ⊥/1440.⏎
  & = ⊥
\end{split}
££.
\end{equation}
}

\begin{reap}
££.fraction.Checked {££
 Ok ok() ->
   -1 < h && h < 24 &&
   -1 < m && m < 60 &&
   -1 < s && s < 60 ;
 Real ¢()-> ok && super.¢;
}
\end{reap}

Note the use of \verb+&&+ and \verb+||+. they also deal with undefined.
Different from Java.
\begin{reap}
££.Checked.Greeting {££
  fraction super.¢ || 0.5;
  String name "David";
  String now() ->
      fraction < 0.50 ££? "morning" :
      fraction < 0.75 ££? "day" :
      "evening"
  ;
  ¢() -> "Hi " + name + ", good " + now + " to you.";
}
\end{reap}

Linear
\begin{reap}
££.Hamlet {££
  Boolean toBe() {££
    toBe = () -> ££!toBe;
    return true;
  }
}
\end{reap}
behaves like flip flop or maybe a clock? bad metaphors

Penny pool notation:
\begin{reap}
££.Hamlet {££
  Boolean ¢() {££ ¢ = () -> ££!¢; return false; }
}
\end{reap}

\begin{reap}
££.Ticker {££
  Integer start 1;
  Integer ¢() {££
      ¢ = () -> ¢ + 1; // Change gate of cell ¢
      return start;
  };
}
\end{reap}

\begin{java}
   a() -> a + 1;
\end{java}
    means
\begin{java}
  ¢ = () -> ¢ + 1;
\end{java}

\begin{java}
  Integer curr() {££ prev = ¢;}
\end{java}
Is actually
\begin{java}
  Integer curr = () -> {££ prev = ¢;}
\end{java}

\begin{reap}
££.Fibonacci {££
  Integer prev 1;
  Integer curr() {££ prev = ¢;}
}
\end{reap}

\begin{reap}
££.AP.Constants {££ // Constant of Arithmetic Progression
  Real a1;
  Real d;
}
\end{reap}

\begin{reap}
££.AP.nTh {££ // Arithmetic Progression
  Integer ¢() -> (a1,¢=()->¢ + d);
}
\end{reap}

\begin{reap}
££.Fibonacci {££ // Compute the Fibonacci sequence
  Integer a1;
  Integer a2;
  Integer ¢ = {££ a1, a2, ¢ = () -> ¢ + ¢[1] };
}
\end{reap}

Interesting step wise! Try to do Fibonacci? Try Fibonacci as a function which creates zillion cells?
\begin{reap}
££.Constants.AP {££ // Arithmetic Progression
  Integer ¢() -> a1 -> ¢ + d;
}
\end{reap}

\begin{align}
  \label{eq:ok}
  ⊤ & = \kk{Ok} = \cc{Void}⏎
  \label{eq:oz}
  ⊥ & = \kk{Oz} = \kk{None} = \cc{@NonNull Void}
\end{align}
Type system is~$𝕋$. In addition to \kk{Ok} and \kk{Oz}, we have atomic types
\kk{Boolean}, \kk{String}, \kk{Integer}, \kk{Real}, and, \kk{Character}.
\begin{equation}
\label{eq:bounds}
∀τ∈𝕋 ∙ ⊥≤τ≤⊤.
\end{equation}

\matteo{read about type Unity which is also OK which is also top in our case}
\begin{reap}
££.fraction.Checked {££
  Ok ok() ->
  // Up casting into type £$⊤ = \kk{Ok}$£, of £…£
  // £…£ an expression of type £\kk{Boolean}£
    0 < h && h < 24 &&
    0 < m && m < 60 &&
    0 < s && s < 60
  ;
  Real ¢()-> ok && super.¢;
}
\end{reap}

\begin{reap}
££.Brothers {££
Integer c, h, g;
}
\end{reap}

\begin{reap}
££.fraction.Checked {££
  Ok ok() ->
  0 < h && h < 24 &&
  0 < m && m < 60 &&
  0 < s && s < 60 ;
  Real ¢()-> ok && super.¢;
}
\end{reap}

\begin{reap}
££.Brothers {££
Integer c, h, g;
}
\end{reap}

Arrays may be represented as previous versions of a cellimport java.util.function.Function;
 
\begin{reap}
class Test {
	public static void main(final String[] args) {
		final int Z = 0;
		final Function<Integer, Function<Integer, Integer>> f = X -> Y -> Z;
		System.out.println(f.apply(0).apply(0));
	}
}
\end{reap}
