\begin{code}{JAVA}
.Fraction.Checked {Â£Â£
  Ok ok() -> 
    0 < h ** h < 24 ** 
    0 < m ** m < 60 ** 
    0 < s ** s < 60 ;
  Real Â¢()->  ok ** super.Â¢; 
}
\end{code}


\begin{code}{JAVA}
.Brothers {Â£Â£
Integer c, h, g;
}
\end{code}

\begin{code}{JAVA}
.Time {Â£Â£
  Integer h 10; // Hours, defaults to 10 
  Integer m 20; // Minutes, defaults to 20 
  Integer s;    // Seconds, defaults to Â£$âŠ¥$Â£  
}
\end{code}
Remove the "=" sign in initialization but not assignment 
\begin{java}
class Time extends Object {Â£Â£
  Integer h = 10; // Hours, initially, Â£$\cc{10}$ 10 
  Integer m = 20; // Minutes, initially Â£$\cc{20}$ 20 
  Integer s;      // Seconds, initially Â£$\kk{null}$ 
}
\end{java}

\begin{code}{JAVA}
.Time.Display {Â£Â£
  String Â¢ = h + ":" + m + ":" + s;    
}
\end{code}
reaches fields directly, just like inheritance.

\begin{code}{JAVA}
.Time.AMPM {Â£Â£
  Boolean isAM  super.h < 12;
  Boolean isPM  !isAM;
  String  ampm  isAM ? "AM" : "PM"; 
  String  h     super.h - (isAM ? 0 : 12);    
}
\end{code}

\begin{code}{JAVA}
.Time.Fraction {Â£Â£
  Real Â¢() -> ((60*h + m) + s)/24./60 ;
}
\end{code}


\begin{code}{JAVA}
.Time.Guess {Â£Â£
  Integer s = 0; 
}
\end{code}

\begin{code}{JAVA}
.Time.Fraction {Â£Â£
  Real Â¢() -> ((60*h + m) + s)/24./60 ;
}
\end{code}

%\begin{code}{JAVA}
%.Fraction.Checked {Â£Â£
%  Ok ok() -> 
%    0 < h && h < 24 && 
%    0 < m && m < 60 && 
%    0 < s && s < 60 ;
%  Real Â¢()->  ok && super.Â¢; 
%}
%\end{code}

\def\ignore#1{}

Note the use of \verb_&&_ and \verb_||_.
\begin{code}{JAVA}{
.Checked.Greeting {Â£Â£
  fraction = super.Â¢ || 0.5;
  String name "David";
  String now ->
      fraction < 0.50 ? "morning" :
      fraction < 0.75 ? "day" :
      "evening"
  ;
  Â£\ignore$Â£$ -> "Hi " + name + ", good " + now + " to you.";
}
\end{code}

\begin{code}{JAVA}
.Hamlet {Â£Â£
  Boolean toBe() {Â£Â£ toBe = () -> !toBe; return false; } 
}
\end{code}
behaves like flip flop or maybe a clock? bad metaphors

\begin{code}{JAVA}
.Hamlet {Â£Â£
  Boolean Â¢() {Â£Â£ Â¢ = () -> !Â¢; return false; } 
}
\end{code}

\begin{code}{JAVA}
.Ticker [
  Integer start 1;
  Integer Â¢ {Â£Â£
      Â¢()  -> Â¢ + 1;
      return start;
  };
\end{code}

Remove the "=" sign in initialization but not assignment 
\begin{java}
   a()  -> a + 1;
\end{java}
    means
\begin{java}
  Â¢ = () -> Â¢ + 1;
\end{java}


\begin{java}
  Integer curr() {Â£Â£ prev = Â¢;}
\end{java}
Is actually 
\begin{java}
  Integer curr = () -> {Â£Â£ prev = Â¢;}
\end{java}

\begin{code}{JAVA}
.Fibonacci {Â£Â£
  Integer prev 1;
  Integer curr() {Â£Â£ prev = Â¢;}
}
\end{code}

\begin{code}{JAVA}
.Constants {Â£Â£ // Of Arithmetic Progression
  Integer a1;
  Integer d;
  Integer curr() {Â¢=()->Â¢ + d; prev = Â¢;}
}
\end{code}

\begin{code}{JAVA}
.Constants.AP {Â£Â£ // Arithmetic Progression
  Integer curr() {Â¢=()->Â¢ + d; return a1;} 
}
\end{code}

Interesting step wise! Try to do Fibonacci? Try Fibonacci as a function which creates zillion cells?
\begin{code}{JAVA}
.Constants.AP {Â£Â£ // Arithmetic Progression
  Integer Â¢() -> a1 -> Â¢ + d; 
}
\end{code}


\begin{align}
  \label{eq:ok}
  âŠ¤ & = \kk{Ok} = \cc{Void}â
  \label{eq:oz}
  âŠ¥ & = \kk{Oz} = \kk{None} = \cc{@NonNull Void}
\end{align}
Type system is~$ğ•‹$.  In addition to \kk{Ok} and \kk{Oz}, we have atomic types
\kk{Boolean}, \kk{String}, \kk{Integer}, \kk{Real}, and, \kk{Character}.
\begin{equation}
\label{eq:bounds}
âˆ€Ï„âˆˆğ•‹ âˆ™ âŠ¥â‰¤Ï„â‰¤âŠ¤.  
\end{equation}


