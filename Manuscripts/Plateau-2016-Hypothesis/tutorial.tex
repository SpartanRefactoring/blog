\begin{Code}{REAP}{Time environment}
Â£Â£.Time {Â£Â£
  Integer h 9; // Hours, defaults to 9
  Integer m 11; // Minutes, defaults to 11
  Integer s; // Seconds, defaults to Â£$âŠ¥$Â£
}
\end{Code}
Remove the "=" sign in initialization but not assignment.`
% vim: /\^:
\begin{Code}[minipage,width=20em]{JAVA}{Time environment transliterated to \Java}
class Time extends Object {Â£Â£
  Integer h = 9; // Hours, initially set to Â£$\cc{9}$Â£
  Integer m = 11; // Minutes, initially set to Â£$\cc{11}$Â£
  Integer s; // Seconds, initially set to Â£$\kk{null}$Â£
}
\end{Code}

\begin{Code}{REAP}{Environment }
Â£Â£.Time.Display {Â£Â£
  String Â¢ = h + ":" + m + ":" + s;
}
\end{Code}
reaches fields directly, just like inheritance.

\begin{Code}[minipage,width=22em]{JAVA}
{\Java transliteration of \texttt{Time.Display}}
class Display extends Time {Â£Â£
  String Â¢() {Â£Â£
     h + ":" + m + ":" + s;
  }
}
\end{Code}

\begin{Code}[minipage,width=20em]{JAVA}%
{More accurate \Java transliteration \\
of \Java \texttt{Time.Display}}
class Time {Â£Â£
  public static class Display extends Time {Â£Â£
    String Â¢() {Â£Â£
       h + ":" + m + ":" + s;
    }
  }
}
\end{Code}

\begin{Code}{REAP}{Environment }
Â£Â£.Time.AMPM {Â£Â£
  Boolean isAM super.h < 12;
  Boolean isPM Â£Â£!isAM;
  String ampm isAM Â£Â£? "AM" : "PM";
  String h super.h - (isAM Â£Â£? 0 : 12);
}
\end{Code}

\begin{Code}{REAP}{Environment }
Â£Â£.Time.Fraction {Â£Â£
  Real Â¢() -> ((60*h + m) + s)/24./60 ;
}
\end{Code}
reads as
\begin{Code}[minipage,width=20em]{JAVA}{ â€¦ \Java â€¦ }
class Fraction extends Time {Â£Â£
  Real Â¢ = ()-> ((60*h + m) + s)/24./60 ;
}
\end{Code}
or so
\begin{Code}[minipage,width=20em]{JAVA}{ â€¦ \Java â€¦ }
class Fraction extends Time {Â£Â£
  Real Â¢() {Â£Â£ return ((60*h + m) + s)/24./60 ; }
}
\end{Code}

\begin{Code}[minipage,width=20em]{JAVA}{ â€¦ \Java â€¦ }
class Time {Â£Â£
  static class AMPM extends Time {Â£Â£ /* Â£$â‹¯$ Â£*/ }
  static class Fraction extends Time {Â£Â£ /* Â£$â‹¯$ Â£*/}
}
\end{Code}

\matteo{read about mixins and traits.start with mixins}

\begin{Code}{REAP}{Environment }
Â£Â£.Time.AMPM.Fraction;
\end{Code}

\begin{Code}[minipage,width=20em]{JAVA}{ â€¦ \Java â€¦ }
class Time {Â£Â£
  static class AMPM extends Time {Â£Â£
    /* Â£$â‹¯$ Â£*/
    static class Fraction extends Time {Â£Â£ /* Â£$â‹¯$ Â£*/}
  }
  static class Fraction extends Time {Â£Â£ /* Â£$â‹¯$ Â£*/}
}
\end{Code}

\begin{code}{REAP}
Â£Â£.Time.Fraction.AMPM;
\end{code}

\begin{Code}[minipage,width=26em]{JAVA}{ â€¦ \Java â€¦ }
class Time {Â£Â£
  static class AMPM extends Time {Â£Â£
    /** Â£$â‹¯$Â£*/
    static class Fraction extends Time {Â£Â£ /* Â£$â‹¯$ Â£*/}
  }
  static class Fraction extends Time {Â£Â£
    /** Â£$â‹¯$Â£*/
    static class AMPM extends Fraction {Â£Â£ /* Â£$â‹¯$ Â£*/}
  }
}
\end{Code}

\begin{Code}{REAP}{Environment }
Â£Â£.Time.Guess {Â£Â£
  Integer s 0;
}
\end{Code}

Whenever a property is undefined it is like a function that throws an exception.
Any time you use it, the called would also be throwing an exception.
\begin{Code}{REAP}{Environment }
Â£Â£.Time.Fraction {Â£Â£
  Real Â¢() -> ((60*h + m) + s)/24./60 ;
}
\end{Code}
To evaluate
\begin{java}
  ((60*h + m) + s)/24./60
\end{java}
replace~$hâ†’9, mâ†’11, sâ†’âŠ¥$
to obtain

{\scriptsize
\begin{equation}
\begin{split}
  Â¢ & = ((60Â·9 + 11) + âŠ¥)/24./60âŽ
  & = ((540 + 11) + âŠ¥)/24./60âŽ
  & = (551 + âŠ¥)/1440. &âŽ
  & = âŠ¥/1440.âŽ
  & = âŠ¥
\end{split}
Â£Â£.
\end{equation}
}

\begin{Code}{REAP}{Environment }
Â£Â£.Fraction.Checked {Â£Â£
 Ok ok() ->
   -1 < h && h < 24 &&
   -1 < m && m < 60 &&
   -1 < s && s < 60 ;
 Real Â¢()-> ok && super.Â¢;
}
\end{Code}

Note the use of \verb+&&+ and \verb+||+. they also deal with undefined.
Different from Java.
\begin{Code}{REAP}{Environment }
Â£Â£.Checked.Greeting {Â£Â£
  fraction super.Â¢ || 0.5;
  String name "David";
  String now() ->
      fraction < 0.50 Â£Â£? "morning" :
      fraction < 0.75 Â£Â£? "day" :
      "evening"
  ;
  Â¢() -> "Hi " + name + ", good " + now + " to you.";
}
\end{Code}

Linear
\begin{Code}{REAP}{Environment }
Â£Â£.Hamlet {Â£Â£
  Boolean toBe() {Â£Â£
    toBe = () -> Â£Â£!toBe;
    return true;
  }
}
\end{Code}
behaves like flip flop or maybe a clock? bad metaphors

Penny pool notation:
\begin{Code}{REAP}{Environment }
Â£Â£.Hamlet {Â£Â£
  Boolean Â¢() {Â£Â£ Â¢ = () -> Â£Â£!Â¢; return false; }
}
\end{Code}

\begin{Code}{REAP}{Environment }
Â£Â£.Ticker {Â£Â£
  Integer start 1;
  Integer Â¢() {Â£Â£
      Â¢ = () -> Â¢ + 1; // Change gate of cell Â¢
      return start;
  };
}
\end{Code}

\begin{java}
   a() -> a + 1;
\end{java}
    means
\begin{java}
  Â¢ = () -> Â¢ + 1;
\end{java}

\begin{java}
  Integer curr() {Â£Â£ prev = Â¢;}
\end{java}
Is actually
\begin{java}
  Integer curr = () -> {Â£Â£ prev = Â¢;}
\end{java}

\begin{Code}{REAP}{Environment }
Â£Â£.Fibonacci {Â£Â£
  Integer prev 1;
  Integer curr() {Â£Â£ prev = Â¢;}
}
\end{Code}

\begin{Code}{REAP}{Environment }
Â£Â£.Constants {Â£Â£ // Constant of Arithmetic Progression
  Integer a1;
  Integer d;
}
\end{Code}

\begin{Code}{REAP}{Environment }
Â£Â£.Constants.AP {Â£Â£ // Arithmetic Progression
  Integer Â¢() {Â¢=()->Â¢ + d; return a1;}
}
\end{Code}

\begin{Code}{REAP}{Environment }
Â£Â£.Constants.AP {Â£Â£ // Arithmetic Progression
  Integer Â¢() -> (a1,Â¢=()->Â¢ + d);
}
\end{Code}

\begin{Code}[minipage,width=22em]{REAP}
{A reap for computing the Fibonacci sequence}
Â£Â£.Fibonacci {Â£Â£
  Integer a1;
  Integer a2;
  Integer Â¢() -> (a1, a2, Â¢=()->Â¢ + Â¢[1]);
}
\end{Code}

\begin{Code}{REAP}{Environment }
class Fibonacci {Â£Â£
  Integer a1;
  Integer a2;
  Integer Â¢() {Â£Â£
    Â¢ = () {Â£Â£ Â¢ = () -> Â¢ + prev(Â¢); return a2;};
    return a1;
  }
}
\end{Code}

Interesting step wise! Try to do Fibonacci? Try Fibonacci as a function which creates zillion cells?
\begin{Code}{REAP}{Environment }
Â£Â£.Constants.AP {Â£Â£ // Arithmetic Progression
  Integer Â¢() -> a1 -> Â¢ + d;
}
\end{Code}

\begin{align}
  \label{eq:ok}
  âŠ¤ & = \kk{Ok} = \cc{Void}âŽ
  \label{eq:oz}
  âŠ¥ & = \kk{Oz} = \kk{None} = \cc{@NonNull Void}
\end{align}
Type system is~$ð•‹$. In addition to \kk{Ok} and \kk{Oz}, we have atomic types
\kk{Boolean}, \kk{String}, \kk{Integer}, \kk{Real}, and, \kk{Character}.
\begin{equation}
\label{eq:bounds}
âˆ€Ï„âˆˆð•‹ âˆ™ âŠ¥â‰¤Ï„â‰¤âŠ¤.
\end{equation}

\matteo{read about type Unity which is also OK which is also top in our case}
\begin{Code}[width=50ex,minipage]{REAP}{Environment }
Â£Â£.Fraction.Checked {Â£Â£
  Ok ok() ->
  // Up casting into type Â£$âŠ¤ = \kk{Ok}$Â£, of Â£â€¦Â£
  // Â£â€¦Â£ an expression of type Â£\kk{Boolean}Â£
    0 < h && h < 24 &&
    0 < m && m < 60 &&
    0 < s && s < 60
  ;
  Real Â¢()-> ok && super.Â¢;
}
\end{Code}

\begin{Code}{REAP}{Environment }
Â£Â£.Brothers {Â£Â£
Integer c, h, g;
}
\end{Code}

\begin{Code}{REAP}{Environment }
Â£Â£.Fraction.Checked {Â£Â£
  Ok ok() ->
  0 < h && h < 24 &&
  0 < m && m < 60 &&
  0 < s && s < 60 ;
  Real Â¢()-> ok && super.Â¢;
}
\end{Code}

\begin{Code}{REAP}{Environment }
Â£Â£.Brothers {Â£Â£
Integer c, h, g;
}
\end{Code}


Arrays may be represented as previous versions of a cell.
