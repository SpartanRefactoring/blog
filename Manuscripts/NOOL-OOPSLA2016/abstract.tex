<<<<<<< HEAD
% Inspired by the declarative features of \cc{make}, we propose \Reap: a tiny
% programming language in which the notion of a class defining methods and fields
% is replaced by that of an \emph{environment} defining \emph{properties}, some
% of which are adorned by \emph{recipes}.  Properties are similar to variables,
%    except that a property whose value was not explicitly set may still yield a
%    value: \Reap's underlying inference engine applies any required recipes to
%    compute this value from values of other properties. 
% 
% Traditional inheritance is replaced in \Reap by both acquisition and reaping.
% In \emph{acquisition}, an environment may either add or overload properties and
% recipes of some other environment. An environment \emph{reaps} another
% environment, by first making a copy of its content, and then adding and
% overloading properties and recipes. 
% 
% Even though recipe application is caching and lazy as in
% \NonCitingUse{Haskell}, \Reap is not functional. In the course of
% computation, properties may be repeatedly set and reset.
% 
% If properties are likened to cells and recipes to functions that reside in them,
% then \Reap can be equated to traditional spreadsheets, except that cells
%    are named rather than being addressed, and \Reap's engine being lazy. 
%    
% \Reap's inheritance model is similar to that of \NonCitingUse{Self} and
% \NonCitingUse{JavaScript}: Reaping is similar to the standard emulation of
% inheritance of classes in prototype based languages, while the acquisition is the
% usual extension in such languages.  However, unlike \NonCitingUse{Self} and
% \NonCitingUse{JavaScript} \Reap is statically typed.
% 
% Interestingly, \Reap embeds in it not only traditional object-oriented and
% prototype-based programming, but also traditional by-value and by-reference
% parameter passing.  
% 
% Presently \Reap is manually transliterated into a \NonCitingUse{Java} program
% which connects to the inference engine library by means of terse calls of
% fluent API. Usability and ensuing particular programming style are demonstrated
% in an implementation of an Eclipse plugin. 


=======
Inspired by the declarative features of \cc{make}, we propose \Reap: a tiny
programming language in which the notion of a class defining methods and fields
is replaced by that of an \emph{environment} defining \emph{properties}, some
of which are adorned by \emph{recipes}.  Properties are similar to variables,
   except that a property whose value was not explicitly set may still yield a
   value: \Reap's underlying inference engine applies any required recipes to
   compute this value from values of other properties. 

Traditional inheritance is replaced in \Reap by both acquisition and reaping.
In \emph{acquisition}, an environment may either add or overload properties and
recipes of some other environment. An environment \emph{reaps} another
environment, by first making a copy of its content, and then adding and
overloading properties and recipes. 

Even though recipe application is caching and lazy as in
\NonCitingUse{Haskell}, \Reap is not functional. In the course of
computation, properties may be repeatedly set and reset.

If properties are likened to cells and recipes to functions that reside in them,
then \Reap can be equated to traditional spreadsheets, except that cells
   are named rather than being addressed, and \Reap's engine being lazy. 
   
\Reap's inheritance model is similar to that of \NonCitingUse{Self} and
\NonCitingUse{JavaScript}: Reaping is similar to the standard emulation of
inheritance of classes in prototype based languages, while the acquisition is the
usual extension in such languages.  However, unlike \NonCitingUse{Self} and
\NonCitingUse{JavaScript} \Reap is statically typed.

Interestingly, \Reap embeds in it not only traditional object-oriented and
prototype-based programming, but also traditional by-value and by-reference
parameter passing.  

Presently \Reap is manually transliterated into a \NonCitingUse{Java} program
which connects to the inference engine library by means of terse calls of
fluent API. Usability and ensuing particular programming style are demonstrated
in an implementation of an Eclipse plugin. 
>>>>>>> ba9046dcc594cc92ec4643e2a45f6218c6dad2ff
