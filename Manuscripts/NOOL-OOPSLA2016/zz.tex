\section{Conclusion}
% \label{sec:conclusion}

In the present hypothesis paper, we introduced \Reap, a programming language 
based on a semi-declarative, semi-procedural paradigm. 
\Reap represent the attempt to apply the underlying principles of 
the common building tools (i.e. \zz{make}, \zz{maven}, etc.) to the domain 
of user interaction, like in the case of the development of an Eclipse plugin.
In the present work we described the basic features of \Reap: the concepts
of \emph{environment}, \emph{property} and \emph{recipe} are illustrated
with the help of some example in a transliterated \Java code.

We believe \Reap should be emulated higher level constructs by as follows:
\begin{description}
  \item[Variables in methods] By environmental acquisition. 
    environments rather than just plain scalars for the four basic types.
  \item [Flip flops] 
  \item [Arrays] This is made by noting that a property can remember, if
    required to, all of its previous values.
  \item [Infinite loops]
  \item[Methods] By environmental acquisition. Can even be defined out of 
    classes. There are two shortcuts: \cc{\$} and \cc{\_} that makes this
    simple. Note that this allows for both positional and named parameter
    passing, e.g., the phrase
\begin{reap}
.Rational.n=3.d=4.r  
\end{reap}
returns $0.75$, whereas 
\begin{reap}
.Rational.n=3.d=0.positive  
\end{reap}
is \kk{True}

  \item[Compound structures] This can be done by allowing properties to contain
    environments rather than just plain scalars of the four basic types. When a
    property is an environment, then its prerequisites' graph is merged into
    the containing environment. The inner properties can then be accessed using
    a Dewey like notation as used in nested records, e.g., \cc{r1.infinite}
    denotes property \cc{infinite} within a property of type \cc{.Rational}.

\end{description}

Presently \Reap is at an early design stage. This hypothesis paper is aimed at
fostering the discussion during the workshop as well as gathering comments,
questions, and thoughts. 

% Inspired by the declarative features of \cc{make}, we propose \Reap: a tiny
% programming language in which the notion of a class defining methods and fields
% is replaced by that of an \emph{environment} defining \emph{properties}, some
% of which are adorned by \emph{recipes}.  Properties are similar to variables,
%    except that a property whose value was not explicitly set may still yield a
%    value: \Reap's underlying inference engine applies any required recipes to
%    compute this value from values of other properties. 
% 
% Traditional inheritance is replaced in \Reap by both acquisition and reaping.
% In \emph{acquisition}, an environment may either add or overload properties and
% recipes of some other environment. An environment \emph{reaps} another
% environment, by first making a copy of its content, and then adding and
% overloading properties and recipes. 
% 
% Even though recipe application is caching and lazy as in
% \NonCitingUse{Haskell}, \Reap is not functional. In the course of
% computation, properties may be repeatedly set and reset.
% 
% If properties are likened to cells and recipes to functions that reside in them,
% then \Reap can be equated to traditional spreadsheets, except that cells
%    are named rather than being addressed, and \Reap's engine being lazy. 
%    
% \Reap's inheritance model is similar to that of \NonCitingUse{Self} and
% \NonCitingUse{JavaScript}: Reaping is similar to the standard emulation of
% inheritance of classes in prototype based languages, while the acquisition is the
% usual extension in such languages.  However, unlike \NonCitingUse{Self} and
% \NonCitingUse{JavaScript} \Reap is statically typed.
% 
% Interestingly, \Reap embeds in it not only traditional object-oriented and
% prototype-based programming, but also traditional by-value and by-reference
% parameter passing.  
% 
% Presently \Reap is manually transliterated into a \NonCitingUse{Java} program
% which connects to the inference engine library by means of terse calls of
% fluent API. Usability and ensuing particular programming style are demonstrated
% in an implementation of an Eclipse plugin. 
% 
% 
