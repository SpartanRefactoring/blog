\begin{flushright}
  \scriptsize
\textsc{de gustibus non est disputandum†{%
    Latin maxim: in matters of taste, there can be no disputes
}}
\end{flushright}
\vspace{-1ex}

The Stackoverlow\urlref{http://stackoverlow.com} community, operating as a whole,
recommends against asking coding style and coding conventions related
questions. Tag \cc{code-styling} and its many synonyms: \cc{code-convention},
\cc{coding-guidelines} are specifically
earmarked\urlref{http://stackoverflow.com/tags/coding-style/info} as

{\scriptsize
\begin{tcolorbox}[colback=green!5!white,colframe=blue!25!white,notitle]
  \textsc{Do Not Use!}
This tag refers to an entirely opinionated subject and is therefore
no longer on-topic. Refactoring, braces, indentation, Hungarian notation, and
other stylistic issues relating to code.
\end{tcolorbox}}

A famous case in point is the \emph{‟religious braces wars”}, the endless
discussion of where and when should curly brackets (‟\cc❴”, ‟\cc❵”) placed.
Questions of this sort often transcend the simple relegation to a matter of an
individual programmer personal style and taste. In some language matters, they
could be relegated to the language designer(s) personal taste. In \Go curly
brackets are obligatory, while semicolons are not%
\urlref{https://golang.org/doc/faq＃semicolons}, while in \Java they braces are
required in \kk{synchronized}, \kk{try}, \kk{catch}, \kk{finally}, and
\kk{switch} but optional in other block structures with only one statement.
In fact, one of the designers of \Java's recently introduced~$λ$-expressions\urlref{%
http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html＃syntax}
even commented
\begin{quote}
  \footnotesize
\emph{‟Where we put the curly braces in code such as Listing~5 will likely
dominate \Java message boards and blogs for years to come”}\urlref{%
  http://www.oracle.com/technetwork/articles/java/architect-lambdas-part1-2080972.html
} (sic).
\end{quote}
on the topic of allowing both \mbox{\cc{()->3}} and \mbox{\cc{()->❴3❵}} in~$λ$-expressions.

Never ending debates of style are not limited to lilliputian matters such as
indentation and braces. Even the Dijksta's maxim ‟\emph{gotos are
evil}”~\cite{Dijkstra:68} was challenged in the scientific
literature~\cite{Knuth:74,Ramshaw:88,Bochmann:73,Sennesh:Gil:16,Zoethout:79,Wulf:79,Clark:84}.

Telling the story of ‟Spartan Programming”, one particular strict coding
guideline†{Since it was first described~\cite{TOOLS:98:Santa:Barbara}
  spartan programming has been used as the coding guideline in teaching
  Technion CS software courses and software projects, and collected some interest
  in the programming community~\cite{Coding:Horror:Spartan}}, \Java, this
  manuscript is also likely to be contentious. Perhaps even more so after
witnessing some spartanized code such as in \cref{figure:accumulate}, which
make look look bizarre to the unaccustomed eye, and very different from
traditional production \Java code.

\begin{figure}
\caption{\label{figure:accumulate}
  Some functions from interface \cc{accumulate},
  used for fluent API in the spartan library (abbreviated).
  }
    \centering
\begin{code}[minipage,width=\columnwidth]{JAVA}
/* £… £*/ addAll(Iterable<? extends T>... tss) {££
  for (Iterable<? extends T> ¢ : tss)
    addAll(¢);
  return this;
}
/* £… £*/ addAll(Iterable<? extends T> ts) {££
  if (ts = null)
    for (T t : ts)
      if (t != null)
        add(t);
  return this;
}
/* £… £*/ to(C c) {££
  return new accumulate<T, C>() {££
    /* £… £*/ elements() {££
        return c;
    }
    /* £… £*/ add(T ¢) {££
        if (¢ == null)
          return this;
        c.add(¢);
        return this;
    }
  };
}
\end{code}
\end{figure}

The code in the figure is drawn from a fluent API module\urlref{%
  https://github.com/SpartanRefactoring/spartan/blob/master/src/il/org/spartan/accumulate.java
} which makes it possible to write fluent snippets
such as \[
  \begin{multlined}
    \text{\cc{accumulate.to(myCollection).add(x).}}⏎
    \text{\cc{.add(y).addAll(anotherCollection)}}.
  \end{multlined}
\]
For brevity, only methods' names, parameters and body are shown;
return type, generic parameters, modifiers and annotations are omitted.

Worthy of note in \cref{figure:accumulate} are the concise (some may say
cryptic) method bodies, the small number of parameters, and the short names of
variables and parameters. Other examples of, perhaps even stranger, spartan
code below demonstrate use of the ternary conditional operator, boolean
expressions, and more. All these are drawn from actual code serving in live
projects.

\subsection{Contribution}
The tendency of style discussions to generate more heat than light, is probably
the reason that the topic is not frequented by scientists.†{%
  A recent search for coding conventions on ‟Scopus"', yielded almost no papers which
refer to the topic.} In fear of this controversiality this paper also tries to
avoid superlatives†{reviewers' comments on failures are doubly
  appreciated.} to the convention.†{some qualitative discussion of this
  sort may be found here~\cite{Gil:2010}.} Our main claims are:
\begin{enumrate}
    \item Spartan programming defines measurable values, e.g., size, 
        number of variables, etc., all derived from common principles
        qualitative teaching of software engineering, and aims at optimizing these.  \item There is an orderly process of minimizing these values, 
        and fragments
        of this process can be, and are, automated.
    \item As shown in the evaluation section, at least one fragment of this
      process achieves more regular code, where the term regularity is
      precisely defined.
\end{enumrate}

Some recent studies~\cite{%
  Gil:Lalouche:16,%
  Goldstein:Moshkovich:2011,
  Zhang:Zheng:Ying:Hassan:2016,
} show that not only individual programmers follow their own programming style,
but also that code style is characteristic of software projects as a whole. It
was also shown that even plain size metrics such as LOC and NOT (number of
tokes NOT) must be normalized for project's idiosyncrasies before making
inter-project comparisons.

Another potential contribution of the present work is in the description of an
automated process for generating a ‟canonical” version of code which
compensates for many of these differences.  Code canonization is achieved by
automatic spartanization, followed by the application of the ``Jack'' tool
(described below), yields code clean from many marks of personal and project
variations, including indentation, variable names, etc., use of conditionals,
variables, etc.

Hindle et alii~\cite{Hindle:Bar:Su:Gabel:Devanbu:12} analyzed a large corpus of
Java software systems, using an approach based on Natural Language Processing
(NLP).  They specifically used the $n$-gram model as a linguistic model to
analyze source code and then they compare the feature of the code corpus with
those of corpus written in natural language. One interesting finding of theirs
is that that buggy code tends to resemble less the rest of the code, or less
natural. Our empirical study employs a related notion, \emph{code regularity}
which was demonstrated to be associated with
readability~\cite{Jbara:Feitelson:14}.

\subsection{Spartanization and Abstract Rewriting Systems}

There are four fragments to the spartanization process: \textbf{S}-structural,
\textbf{N}-nominal, \textbf{C}-cleanup, and \textbf{M}-modular. All four might
be thought of as abstract rewriting systems (ASR), more specifically, term
rewrite system. In each fragment, rewrite rules are non-deterministically
selected and applied to the code's AST. 

From a theoretical perspective the most interesting fragment is \textbf{S},
dealing with structural transformations, including, but not limited to, removal
of braces, early returns, inlining etc.  The fragment is unique in being both
non-etherian and non-confluent, i.e., there is no infinite chain of rewrites,
but there is no single normal form.  Termination is guaranteed, since each rule
(wring in the spartan lingo) is reducing (with respect to the minimization
ends) 

In contrast, the \textbf{M}-modular fragment is (at this stage) more of a
recommendation to humans to creatively employ method extraction, and in some
cases inlining, to achieve the spartan look. (We believe that some of this
process can be automated though.) 

In terms of abstract term rewriting, fragments~\textbf{C} and~\textbf{N} are
more mundane. The \textbf{N} fragment offers rules (wrings) for enforcing the
lacnonic variale naming convention. It is, determinisic---spartan programming
name suggestions are unequivocal. Fragment \textbf{N} is also trivially
non-size increasing, and reaches a unique normal after a finite number of
steps. 

Least important is the non-essential~\textbf{C} fragment, which relies on an
external tool for making, not necessarily size decreasing, transformation of
the code in attempt to reduce the number of warnings. In our
implementation,~\textbf{C} is realized with the Eclipse cleanup tools.

The evaluation part here is concerned with fragments~\textbf{S} 
and~\textbf{N}.  The expectation is that spartanization not only 
reduces size, but it also makes the resulting code more regular,
i.e., more compressible than the original. As we shall expalin, 
not trivial. Results are that~\textbf{S} passes this trial by fire,
but inconclusive with regard to \textbf{N}. 

