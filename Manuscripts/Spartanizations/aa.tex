As a whole, the stackoverlow\urlref{http://stackoverlow.com} community
recommends against asking coding style and coding conventions related questions.
Tag \cc{code-styling} and its many synonyms: \cc{code-convention},
\cc{coding-guidelines} are specifically
earmarked\urlref{http://stackoverflow.com/tags/coding-style/info} as

\begin{tcolorbox}[colback=green!5!white,colframe=blue!25!white,notitle]
    \textsc{Do Not Use!} 
This tag refers to an entirely opinionated subject and is therefore
no longer on-topic. Refactoring, braces, indentation, Hungarian notation, and
other stylistic issues relating to code.
\end{tcolorbox}

But it is not only curly braces matters that may raise
this kind of ‟religious” wars. Even the Dijksta's maxim ‟\emph{gotos
are evil}”~\cite{Dijksta:must be in bib} was challenged in the scientific
literature~\cite{Knuth: and there are several others}.

Telling the story of ‟Spartan Programming”, one particular style guideline for
\Java, this manuscript is also likely to be contentious. Perhaps even more so
after examining some ‟spartanized” code such as in \cref{figure:first}. 

\begin{figure}[h]
\label{figure:first}
\caption{An example of spartan code}
  \begin{Code}{JAVA}{Where was this taken from?}
public static <T, C extends Collection<T>> accumulate<T, C> 
  to(final C c) {
    return new accumulate<T, C>() {
      @Override public C elements() {
        return c;
      }
      @Override public accumulate<T, C> 
        add(final @Nullable T ¢) {
          if (¢ == null)
            return this;
          assert ¢ != null;
          c.add(¢);
          return this;
        }
    };
  }
\end{Code}
\end{figure}

\begin{figure}[h]
\begin{Code}{JAVA}{Where was this taken from?}
default accumulate<T, C> 
    addAll(final Iterable<? extends T>... tss) {
      for (final Iterable<? extends T> ¢ : tss)
        addAll(¢);
      return this;
    }
\end{Code}
\label{figure:shock-2}
\caption{An example of spartan code}
\end{figure}

\begin{figure}[h]
\begin{Code}{JAVA}{Where was this taken from?}
/** Tests for primality.
  * @param ¢ candidate to be tested
  * @return <code><b>true</b></code> <i>iff</i> the parameter is prime. */
public static boolean isPrime(final int ¢) {
  return ¢ < -1 && isPrime(-¢) // deal with negative values
      || ¢ > 1 && isPrime¢(¢); // any integer >- 2
}
private static boolean isPrime¢(final int i) {
  for (int ¢ = 2; ¢ * ¢ <= i; ++¢)
    if (i ％ ¢ == 0)
      return false;
  return true;
}
\end{Code}
\end{figure}

\begin{figure}[h]
  \begin{Code}{JAVA}{Where was this taken from?}
default Set<Variable> freeVariables() {
    final Set<Variable> $ = new LinkedHashSet<>();
    if (isVariable())
      $.add((Variable) this);
    else
      for (final Term ¢ : this)
        $.addAll(¢.freeVariables());
    return $;
  }
\end{Code}
\label{figure:shock-3}
\caption{An example of spartan code}
\end{figure}

may look bizzare to eyes accustomed to traditional \Java code.

This manuscript reports in

Mention that \Go forces you to use them!
Mention that are compulsory in \kk{synchronized},
\kk{try},
\kk{catch},
\kk{finally},

but on the other hand, in a recent addition lambda expressions~\cite{lambda}
the options are maintained.
You can write
\begin{JAVA}
()-> 3
\end{JAVA}
and
\begin{JAVA}
  ()-> {3}
\end{JAVA}
check this.

‟\emph{the braces war}”

Why should this be important?
\begin{itemize}
    \item Easy to write in your own style, but how can
      you always adjust to the style of others.
      Waste of neurons.
    \item Code comparison. Which part of my change is semantically and which
      part of this my own personal style.
    \item Code analysis tools should adjust to different styles and many
        different ways for doing the same thing.
    \item METRICS: IN a recent paper Gal and I showed that size
      is the only thing that matters.
    \item METRICS: IN a recent paper Gal and I showed that the notion of
      "size" is very different in different projects.
\end{itemize}

The holly grail of "canonical representation of code" .
Does LOC mean anything?
Not if you apply different indentation rules.
A better metric is NOT = number of tokens.
But even this is influenced by coding styles, including but
not limited to the famous braces war.

\subsection{Background}

Despite the fact that coding style is a topic that might lead developers to engage heated 
discussions, to the best of the author's knowledge, there is actually very little scientific 
work on that. 

If one queries for ``code conventions''
\footnote{On text, abstract and keywords and restraining the outcomes to the ``Computer Science''
disciplinary area} 
on Scopus\footnote{http://scopus.org}, one of the most important bibliographic databases, what it comes out is around 
thousands of results\footnote{The search was performed on August 2016}. 
However, very few of them  have \kk{code conventions} among they
keywords and deal with code conventions

This alleged \emph{nonchalance} shown by the scientific community towards the investigation 
of a rationale approach to the problem of defining effective code conventions, might be 
related to the fact that when it comes to code styling most of the dialectic efforts are devoted
to make each personal preferences prevail against the others.

This tendency to trasform technical discussions on disputes about personal preferences 
in matter of code readability, maintenability (not to mention the developers' efficiency) might 
have led Stackoverflow managers to the decision reported in the Introduction, embracing the 
wiseness of the ancient latins who were used to say that \emph{De gustibus non est disputandum}.

Nowithstanding what reported above, code conventions are considered a worthwhile issue during 
the development process, otherwise we would not find style guides for the most important 
programming languages like (Java, C++, etc.) and from the major players worldwide in 
the ITC arena, like Oracle and Google \cite{}. 

But where these styles a matter of a careful and raional design process?
What were the underlying principles.

Last paragraph: many people believe that style is irrelevant and unimportant.
We believe that it is.

\subsection{Spartan programming}
First occurred in a stupid TOOLS USA 199X. tutorial.
The point of making and perfecting it was to "be rational" and
reexamine all assumptions.
Rules have changed.
Utter despise of backward compatability the need to rewrite the code.

Mention it. The spartanization tool.

Say that some of your alma mater gang love to do this kind of metrics, but
no one really knows whether the results are applicable to different projects
since \cite{Turnu:Concas:Marchesi:Tonelli:11}

the "Idionsyncratic Projects Hypothesis" I also had a plateau paper with
Dany and Maayan about this. A number o years ago.

This paper gives an overview of spartanization, future work will be
experiments.

\subsection{Contribution}

\textbf{(the following text has been adapted by the wiki)}⏎

Spartan programming is an approach to writing code aimed at improving at
reducing code complexity by appling many techininques, some already known in
literature, some others more novel. It was introduced in the mid on nienties
and it has been a part of some teachings. Its rationale is based on some
principles, but at the end of the day it is a techninque to pursue an extreme
minimalism code writing.

One of these principles is the "Babylonian Tower Principle": It states that the
number of abstraction levels of a software systems is limited. A famous study
by Miller, also proved that the cognitive burden people might bear, namely the
number of cognitive items that can be processed in human being working memory,
is limited to 7 (plus or minus two) elements. By simplifying the basic element
of more complex, structured composite component, spartan programming reduce the
developers' cognitive burden.

However, being in a certain sense, counter intuitive, in order to apply
Spartanization on their working routines, the developers need to respect a firm
discipline. From a certain standpoint, Spartan Programming might be seen as a
list of code style prescription, but it would just scratch the surface. It is
far more than that, since it

Being minimized, spartanized code might be less readable that the original.
This is ... Spartan programming is not directly concerned with readability, at
least not in its subjective and cultural-dependent sense. In fact, spartan
programs will bring much misery to anyone preferring long, verbose programs.

Spartanization aims at minimizing Vertical complexity (the number of lines of code),
Horizontal complexity, the number of tokens, character, parameters and variables,
as well as reduce the number of loops and conditional statements.
Spartan programming prescribes, a careful use of the variables, stressing the need
to inline variables that are used only once and emphasizing the use of foreach loops
in languages implementing it. Variables visibility and accessibility should also be
possibly minimized, favoring the use of private over public variables whenever it
is possible.

Also the names of variables should be taken short for local variables, with short scope,
leaving to their class names to explicit their behavior. Minimizing variability using
final and @NonNull annotation. Stress the use of generic names technique. Minimize lifespan
avoiding persistent variables when it is possible. Favor the use of collection instead
of arrays. Interfaces should present a minimal number of parameters, also minimizing
the interaction between them. Favor ternarization over the use of if-then-else constructs
and use a simplified version of the conditionals that implies an early return. Moreover,
use an early exit logic with continue, break and return instructions.

Everything should be formatted in order to make an efficient use of the screen space,
by removing unnecessary tokens (i.e., redundant parentheses, etc.).
Methods should be as short as possible.
