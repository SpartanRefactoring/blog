\begin{flushright}
  \scriptsize
\textsc{de gustibus non est disputandum†{%
    Latin maxim: in matters of taste, there can be no disputes
}}
\end{flushright}
\vspace{-1ex}

The Stackoverlow\urlref{http://stackoverlow.com} community, operating as a whole,
recommends against asking coding style and coding conventions related
questions. Tag \cc{code-styling} and its many synonyms: \cc{code-convention},
\cc{coding-guidelines} are specifically
earmarked\urlref{http://stackoverflow.com/tags/coding-style/info} as

{\scriptsize
\begin{tcolorbox}[colback=green!5!white,colframe=blue!25!white,notitle]
  \textsc{Do Not Use!}
This tag refers to an entirely opinionated subject and is therefore
no longer on-topic. Refactoring, braces, indentation, Hungarian notation, and
other stylistic issues relating to code.
\end{tcolorbox}}

A famous case in point is the \emph{‟religious braces wars”}, the endless
discussion of where and when should curly brackets (‟\cc❴”, ‟\cc❵”) placed.
Questions of this sort often transcend the simple relegation to a matter of an
individual programmer personal style and taste. In some language matters, they
could be relegated to the language designer(s) personal taste. In \Go curly
brackets are obligatory, while semicolons are not%
\urlref{https://golang.org/doc/faq＃semicolons}, while in \Java they braces are
required in \kk{synchronized}, \kk{try}, \kk{catch}, \kk{finally}, and
\kk{switch} but optional in other block structures with only one statement.
In fact, one of the designers of \Java's recently introduced~$λ$-expressions\urlref{%
http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html＃syntax}
even commented
\begin{quote}
  \footnotesize
\emph{‟Where we put the curly braces in code such as Listing~5 will likely
dominate \Java message boards and blogs for years to come”}\urlref{%
  http://www.oracle.com/technetwork/articles/java/architect-lambdas-part1-2080972.html
} (sic).
\end{quote}
on the topic of allowing both \mbox{\cc{()->3}} and \mbox{\cc{()->❴3❵}} in~$λ$-expressions.

Never ending debates of style are not limited to lilliputian matters such as
indentation and braces. Even the Dijksta's maxim ‟\emph{gotos are
evil}”~\cite{Dijkstra:68} was challenged in the scientific
literature~\cite{Knuth:74,Ramshaw:88,Bochmann:73,Sennesh:Gil:16,Zoethout:79,Wulf:79,Clark:84}.

Telling the story of ‟Spartan Programming”, one particular strict coding
guideline†{Since it was first described~\cite{TOOLS:98:Santa:Barbara}
  spartan programming has been used as the coding guideline in teaching
  Technion CS software courses and software projects, and collected some interest
  in the programming community~\cite{Coding:Horror:Spartan}}, \Java, this
  manuscript is also likely to be contentious. Perhaps even more so after
witnessing some spartanized code such as in \cref{figure:accumulate}, which
make look bizarre to the unaccustomed eye, and very different from
traditional production \Java code.

\begin{figure}
\caption{\label{figure:accumulate}
  Some functions from interface \cc{accumulate},
  used for fluent API in the spartan library (abbreviated).
  }
    \centering
\begin{code}[minipage,width=\columnwidth]{JAVA}
/* £… £*/ addAll(Iterable<? extends T>... tss) {££
  for (Iterable<? extends T> ¢ : tss)
    addAll(¢);
  return this;
}
/* £… £*/ addAll(Iterable<? extends T> ts) {££
  if (ts = null)
    for (T t : ts)
      if (t != null)
        add(t);
  return this;
}
/* £… £*/ to(C c) {££
  return new accumulate<T, C>() {££
    /* £… £*/ elements() {££
        return c;
    }
    /* £… £*/ add(T ¢) {££
        if (¢ == null)
          return this;
        c.add(¢);
        return this;
    }
  };
}
\end{code}
\end{figure}

The code in the figure is drawn from a fluent API module\urlref{%
  https://github.com/SpartanRefactoring/spartan/blob/master/src/il/org/spartan/accumulate.java
} which makes it possible to write fluent snippets
such as \[
  \begin{multlined}
    \text{\cc{accumulate.to(myCollection).add(x).}}⏎
    \text{\cc{.add(y).addAll(anotherCollection)}}.
  \end{multlined}
\]
For brevity, only methods' names, parameters and body are shown;
return type, generic parameters, modifiers and annotations are omitted.

Worthy of note in \cref{figure:accumulate} are the concise (some may say
cryptic) method bodies, the small number of parameters, and the short names of
variables and parameters. Other examples of, perhaps even stranger, spartan
code below demonstrate use of the ternary conditional operator, boolean
expressions, and more. All these are drawn from actual code serving in live
projects.

\subsection{Rationale}

The tendency of style discussions to generate more heat than light, is probably
the reason that the topic is not frequented by scientists.†{%
  A recent search for coding conventions on ‟Scopus"', yielded almost no papers which
refer to the topic.} In fear of controversiality this paper tries to avoid
superlatives, non-consensual adjectives, and qualitative judgments†{reviewers'
comments on failures are doubly appreciated.} to the
convention.†{some qualitative discussion of this
  sort may be found here~\cite{Gil:2010}.}

 Our main claims are:
\begin{enumerate}
    \item Spartan programming defines measurable values, e.g., size, number of
      variables, etc., all derived from common qualitative principles
        software engineering, and aims at minimizing these.
    \item There is an orderly process of minimization,
      and some of the fragments of this process can be automated.
     We further present a prototype tool for this automation.
    \item as shown in the evaluation section, at least one fragment of this
      process achieves more regular code, where the term regularity being
      precisely defined.
\end{enumerate}

 The spartan paradigm is unique in its extreme demand that automatic
  spartanization is applied to its fullest extents, with disregard
  to other concerns.
As a result, heavily spartanized code may raise complaints.
Concerns were expressed that with extreme inlining of variable
violates the law of Demeter~\cite{Lieberherr:96}, and makes debugging more difficult.
Other complaints are of the use of hard to type non-ASCII characters,
  unpronounceable names (e.g., \cc{sss}).
Yet another dimension of concerns lies with the extensive
  use of the ternary operator, ‟$·$~\cc{?}~$·$~\cc{:}~$·$”, which some find
  less readable than plain \kk{if}, and the loss of modular
  structure†{in the classical sense, i.e., one exit point per
  code block} with short-circuit Boolean operators, as in e.g., \cref{figure:cell1}
  ahead.

The spartan answer to these is that once the decision to minimize, e.g.,
  variability has been made, the introduction of other competing requirements
  confuses matters.
Complaints are therefore answered by suggesting more powerful
  debuggers, keyboards and other tools, the understanding the
  that other rules might be broken, and the fact that eyes that
  trained to understand code, can also learn reading, e.g., short-circuit
  operators.

The rationale is that even though careful balancing of conflicting quality
  demands is important, it can only be wisely made after we have understood the
  implication of each of these individually.
To promote this understanding, one must first try to make a candid effort to
  prioritize certain principles over others.
Spartanization does precisely that, preferring small size, minimal vocabulary
  and variability and other elements of laconic speech over other legitimate
  concerns.
Spartan code may be liked, or disliked, by programmers†{our biased experience
  is that once understood, it is appreciated and often adopted} but it must be
  defined and practiced, to be subjected to quantitative studies as the one
  reported here.

The same reasoning applies to other resolution of style debates; one may also
  insist on forbidding non-modular structures, or language definition that
  allows only one for of indentation, or making any violation of the law of
  Demeter into a compile time error.
Some similar attempts were made in the past, with varying degree of success.
\Pascal does not allow short-circuit operators for a reason, \Haskell forgoes
variables entirely, \Go enforces its braces and semicolons style,
and \Python its own indentation style. In contrast with these and similarly to
other style checkers, spartan code does not invent a new language.
The process of code spartanization is hosting its monastic practices on an
existing language.

\subsection{Other contribution}

Some recent studies~\cite{%
  Gil:Lalouche:16,%
  Goldstein:Moshkovich:2011,
  Zhang:Zheng:Ying:Hassan:2016,
} show that not only individual programmers follow their own programming style,
but also that code style is characteristic of software projects as a whole. It
was also shown that even plain size metrics such as LOC and NOT (number of
tokes NOT) must be normalized for project's idiosyncrasies before making
inter-project comparisons.

Another potential contribution of the present work is in the description of an
automated process for generating a ‟canonical” version of code which
compensates for many of these differences. Code canonization is achieved by
automatic spartanization, followed by the application of the ‟Jack” tool
(described below), yields code clean from many marks of personal and project
variations, including indentation, variable names, etc., use of conditionals,
variables, etc.

Hindle et alii~\cite{Hindle:Bar:Su:Gabel:Devanbu:12} analyzed a large corpus of
Java software systems, using an approach based on Natural Language Processing
(NLP). They specifically used the~$n$-gram model as a linguistic model to
analyze source code and then they compare the feature of the code corpus with
those of corpus written in natural language. One interesting finding of theirs
is that buggy code tends to resemble less the rest of the code, or less
natural. Our empirical study employs a related notion, \emph{code regularity}
which was demonstrated to be associated with
readability~\cite{Jbara:Feitelson:14}.

\subsection{Spartanization and Abstract Rewriting Systems}

There are four fragments to the spartanization process: \textbf{S}-structural,
\textbf{N}-nominal, \textbf{C}-cleanup, and \textbf{M}-modular. All four might
be thought of as abstract rewriting systems (ASR), more specifically, term
rewrite system. In each fragment, rewrite rules are non-deterministically
selected and applied to the code's AST.

From a theoretical perspective the most interesting fragment is \textbf{S},
dealing with structural transformations, including, but not limited to, removal
of braces, early returns, inlining etc. The fragment is unique in being both
non-etherian and non-confluent, i.e., there is no infinite chain of rewrites,
but there is no single normal form. Termination is guaranteed, since each rule
(wring in the spartan lingo) is reducing (with respect to the minimization
ends)

In contrast, the \textbf{M}-modular fragment is (at this stage) more of a
recommendation to humans to creatively employ method extraction, and in some
cases inlining, to achieve the spartan look. (We believe that some of this
process can be automated though.)

In terms of abstract term rewriting, fragments~\textbf{C} and~\textbf{N} are
more mundane. The \textbf{N} fragment offers rules (wrings) for enforcing the
laconic variable naming convention. It is, deterministic---spartan programming
name suggestions are unequivocal. Fragment \textbf{N} is also trivially
non-size increasing, and reaches a unique normal after a finite number of
steps.

Less important is the non-essential~\textbf{C} fragment, which relies on an
external tool for making, not necessarily size decreasing, transformation of
the code in attempt to reduce the number of warnings. In our
implementation,~\textbf{C} is realized with the Eclipse cleanup tools for minor
tasks such as adding \kk{final} modifier, removing unused members, etc.

The evaluation part here is concerned with fragments~\textbf{S}
and~\textbf{N}. The expectation is that spartanization not only reduces size,
but it also makes the resulting code more regular, i.e., more compressible than
the original. As we shall explain, not trivial. Results are that~\textbf{S}
passes this trial by fire. We remain inconclusive on whether this is true for
the \textbf{N} fragment.
