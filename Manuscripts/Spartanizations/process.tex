The spartan programming style tries to achieve terse, clear and modular code,
by \textit{simultaneous} minimization of these measures or \emph{minimization
ends}:
\begin{enumerate}
  \item \textit{code size,} which here means all of number of lines, number of
        characters, \emph{and}, number of language tokens;
  \item \textit{vertical complexity,} e.g., the number of lines in each
        method;
  \item \textit{horizontal complexity,} including, the number of parameters to a
        module (method or generic class), \emph{and} the level of nesting of
        control commands, \kk{if}, \kk{while}, \kk{switch}, etc. However,
        horizontal complexity does not concern line length, which is generally
        discarded by spartanization.
  \item \textit{control complexity,} which is the total number of control
        commands in the code.
  \item \textit{variability,} which means minimizing visibility, ability to
        change, lifetime, and scope of variables, just as their number.
        This means the introduction of \kk{final} whenever possible,
        variable inlining, preferring local variables to parameters, parameters
        to fields, and fields to \kk{static} fields, careful use of
        \cc{public}, etc.
  \item \textit{exploitation of environment,} which means the number of
    distinct identifiers (of fields, methods, etc.) used in any module.
  \item \textit{life and size of stacked context,} which is the most intricate of the
        spartan minimization ends.

        To understand what terms stacked context and its life mean, consider
        this code snippet

\begin{code}[minipage,width=54ex]{java}
ThingTwo ii = new ThingTwo();
ii.wreck(house);
System.out.println(ii);
ThingOne i = new ThingOne(); // Stack context of £\cc{ii}£
System.out.println(i); // Context of £\cc{ii}£ still stacked
i.wreck(house); // Stacked still£…£
System.out.println(i); // Still!
cat.join(i, ii); // Finally: recalling context of £\cc{ii}£.
  \end{code}
  The last line in this snippet joins the three objects,
  \cc{cat},~\cc{i}, and \cc{ii}. The four preceding lines prepare
  and print object~\cc{i}.

  Object~\cc{i} is prepared and printed in the remainder, i.e., the first three
  lines of the snippet. The fact that it existed is stacked then during the
  preparation of~\cc{i}, and restored only at the last line.

  By swapping the order of construction, we obtain code in which the stacked is
  a bit shorter,~\cc{i} instead of~\cc{ii}, and in a linear read of the
  program, it is stacked for three lines rather than four.

\begin{code}[minipage,width=54ex]{java}
ThingOne i = new ThingOne();
System.out.println(i);
i.enter(house);
System.out.println(i);
ThingTwo ii = new ThingTwo(); // Stack context of £\cc{i}£.
ii.enter(house); // Context of £\cc{i}£ still stacked.
System.out.println(ii); // Context is stacked still.
cat.join(i, ii); // Recalling context of £\cc{ii}£.
  \end{code}
\end{enumerate}

\subsection{Rationale}
\label{section:rationale}
To an extent, these minimization ends are reformulation of traditional belief
on software: that software should be organized in short cohesive modules whose
code depends on few globals, and is frugal in its use of control. Conversely,
complaints on code quality, include deep and complex nesting \kk{if}s and
\kk{for}s, endless parameters' lists, piles of global variables and many
methods and classes that should be understood before understanding any given
method, etc.

Also, the end of minimizing life and size of saved contexts captures in it
principles such as early \cc{throw}, \cc{return} and \cc{break} (from loops) on
errors, ordering by increasing length to increase readability, and also the
practice of placing at first the short branch of an \cc{if} conditional, etc.

Unlike other coding guidelines, spartanization prescribes a (semi-automatic)
uncompromising process by which code can be spartanized. The central novelty
therefore in spartan programming is not in these numerical minimization ends,
but in the \emph{manner}, \emph{extent}, and \emph{automation} of the quest
for their optimization. The last three \emph{emphasized} words make the titles
of \cref{section:manner}, \cref{section:extent}, and \cref{section:automation}
ahead.

\subsection{Manner of application}
\label{section:manner}
The spartanization process is governed by the spartan
\emph{toolbox}, which is a collection of many (currently around sixty)
structural and nominal wrings. Each \emph{wring} is a refactoring that does
not degrade quality as measured by any of minimization ends: LOC, number of
tokens, nesting level, size of stacked scope, etc., while improving at least
one of them.

A \emph{structural wring} is a wring that modifies the structure of the code, A
simple structural wring is the one removing useless \kk{abstract} and
\kk{public} modifiers from declarations made within an \kk{interface}.
The application of a chain of structural wrings converts
\vspace{-2ex}

\begin{quote}
\begin{tabular}{m{15ex}m{4ex}m{10ex}}
\begin{java}
if (f() == true) {££
  return false;;
} else {££
  return true;;
}
\end{java}
& into &
\begin{java}
££
££
  return !f();
\end{java}
\end{tabular}
\end{quote}
\vspace{-4ex}

This chain includes a wring to remove redundant curly brackets and
one for the removal of redundant semicolons. Also involved is a wring for the
conversion of an \kk{if} into to a \emph{ternary} expression (one employing the
operator~\cc{$·$?$·$:$·$}), and a wring simplifying of ternary expressions
involving boolean literals.

In contrast, a \emph{nominal wring} is a wring that does not modify the
code itself, but renames some entities in it, most particularly, variables.
For example, the toolbox includes a nominal wring to convert the name of the
variable returned by a method, to the one character identifier ‟\cc{\$}”,
which is the short spartan name for result.

If none of the wrings in the toolbox is applicable to the code, then
spartanization has reached a (local) optimum. Otherwise, code spartanization
proceeds by selecting one such wring and continuing with the code obtained
after applying this wring.

This process can be automated or carried out interactively. Many of the wrings
are implemented as part of an open source spartan refactoring Eclipse
plugin\urlref{https://github.com/SpartanRefactoring/spartan-refactoring} which
makes it possible for programmers to apply much of it.

In addition to wrings, spartanization may use
\begin{itemize}
    \item cleanup by external tools, specifically, Eclipse's cleanup operation,
      to tasks such as minimizing variability as planting \kk{final} modifier
      whenever possible, removing unused variables and methods, removing
      unnecessary parenthesis, etc.
    \item user intervention for appropriate
        clever method extraction, and other modular restructuring to
        minimize e.g., exploitation of environment.
\end{itemize}
Naturally, size increases with the addition of \cc{final}s; other cleanups, such
as the automatic addition of \cc{@Override} annotation may increase size as well.
Also, typically method extraction and other modular transformations increases
code size, be it measured in lines, tokens, characters or bytes.

Thus, there are four components to the spartanization process:
\emph{\textbf{(i)}} structural,
\emph{\textbf{(ii)}} nominal,
\emph{\textbf{(iii)}} cleanup, and,
\emph{\textbf{(iv)}} modular.
Current technology can automate all but the last component;
automation of method extraction requires more research,
paying attention to current state of the art
~\cite{Griswold:Chen:Morison:Bowdidge:1998,
Holmes:Murphy:2005}.
This section is concerned with the full process of spartanization.
The empirical \cref{section:initial} below investigates how structural and
nominal spartanizations contribute to the naturalness of code.

\subsection{Extent of application}
\label{section:extent}
An underlying principle is not only that the minimization of
the above ends matters, but also that \emph{nothing else matters}.
In other words, wrings are applied repeatedly, with explicit disregard
to any other extent†{%
  In the Spartan's words: ‟\textit{As far as this can reach}.” K. Agesilaus the
  great (\textsl{being asked for the extent of Sparta's border, while
  holding his spear}).
}.

Heavily spartanized code is often quite different than the original. A case in
point can be found in generic class \cc{C0}, defined by the programmer to
include only instance field \cc{inner} of the generic type parameter.

\begin{figure}[H]
  \caption{\label{figure:cell0}%
    A generic class representing a cell, along with its Eclipse
  automatically generated methods (28 lines, 94 words, and 649 characters).}
    \begin{adjustbox}{max width=\columnwidth}
% VIM: /begin/+,/end/-!wc
\begin{code}[minipage, width=1.25\columnwidth]{JAVA}
public class C0<T> {££
  private T inner;
  public C0(T inner) {££
    super();
    this.inner = inner;
  }
  public int hashCode() {££
    final int prime = 31;
    int result = 1;
    result = prime * result + ((inner == null) ? 0 : inner.hashCode());
    return result;
  }
  public boolean equals(Object obj) {££
    if (this == obj)
      return true;
    if (obj == null)
      return false;
    if (getClass() != obj.getClass())
      return false;
    C0 other = (C0) obj;
    if (inner == null) {££
      if (other.inner != null)
        return false;
    } else if (!inner.equals(other.inner))
      return false;
    return true;
  }££
}££££
\end{code}
\end{adjustbox}
\end{figure}

\Cref{figure:cell0} portrays this class along with function members
automatically generated by Eclipse: a constructor and the trivial methods
\cc{equals($·$)} and \cc{hashCode()} methods.

Compare this figure to its spartanized terse version in \cref{figure:cell1}.

\begin{figure}[H]
  \caption{\label{figure:cell1}%
    A spartanized version of the \Java class in \cref{figure:cell0}
    automatically generated methods (16 lines, 70 words and 424 characters).}
    \begin{adjustbox}{max width=\columnwidth}
% VIM: /begin/+,/end/-!wc
\begin{code}[minipage, width=1.25\columnwidth]{JAVA}
public class C1<T> {££
  private final T inner;
  public C1(T inner) {££
    this.inner = inner;
  }
  public int hashCode() {££
    return 31 + ((inner == null) ? 0 : inner.hashCode());
  }
  public boolean equals(Object ¢) {££
    return ¢ == this || //
      ¢ != null && getClass() == ¢.getClass() && equals((C1) ¢);
  }
  private boolean equals(C1 ¢) {££
    return inner == null ? ¢.inner == null : inner.equals(¢.inner);
  }
}
\end{code}
\end{adjustbox}
\end{figure}

Evidently, spartanization has removed all conditionals, replacing these with
the ternary operator and the short-circuit operators, ‟\cc{\textbar\textbar}”
and ‟\cc{＆＆}”. Spartanization also abbreviated \cc{obj} to~\cc{o} and then
renamed it to~\cc{¢}, eliminated the spurious \cc{\kk{super}()} call in the
constructor, as well as the two variables use in \cc{hashCode()}, turning the
function into a single expression.

The resulting code is evidently shorter, and not as nested. Arguably, the code
is also easier explain and understand: For example, function \cc{equals(Object
¢)} in the figure is described by its own code, while relying on the
understanding of the Boolean operators

\vspace{-1ex}
\begin{quote}\itshape\scriptsize
  If the sent parameter is the same as \cc{this}, then equality is guaranteed.
  Otherwise, the parameter must not be \kk{null}, and must be of the same class
  of \kk{this}. Further, the parameter must also be of the same as class as
  \kk{this}, and equal to \kk{this} also as an instance of this class.
\end{quote}
\vspace{-1ex}

Notice though that line length, which is not optimized by the wrings, suffered
a bit. We do have fewer lines, but the average number of characters in them
increased from 23 characters to 26.5. Also, the maximal line length increased
from 71 characters to 81. This last increase is though due to the
extraction of a \kk{private} version of \cc{equals($·$)}, which is carried
out manually, at user's discretion.

\subsection{Automation}
\label{section:automation}
Consider the \Java program presented in \cref{figure:eclipse}, drawn from the
Eclipse JDT Tutorial series\urlref{%
http://www.programcreek.com/2011/01/a-complete-standalone-example-of-astparser},
but slightly amended for brevity.

\begin{figure}[H]
  \caption{\label{figure:eclipse}%
    A complete standalone example of using class \cc{ASTParser}, drawn
    from the Eclipse JDT Tutorial Series, abbreviated and reformatted.}
    \begin{adjustbox}{max width=\columnwidth}
      \begin{code}[minipage, width=1.13\columnwidth]{JAVA}
public class Test0 {££ // comments and £\kk{import}£ directives omitted for brevity
  public static void main(String args[]) {££
    ASTParser parser = ASTParser.newParser(AST.JLS3);
    parser.setSource((
      "public class A {\n" +
      " int i = 9;\n"+ //
      " int j;\n" + //
      " ArrayList<Integer> al = new ArrayList<Integer>();\n" + //
      " j=1000;\n" + //
      "}\n").toCharArray());
    parser.setKind(ASTParser.K£\_£COMPILATION£\_£UNIT);
    CompilationUnit cu = (CompilationUnit) parser.createAST(null);
    cu.accept(new ASTVisitor() {££
      Set names = new HashSet();
      public boolean visit(VariableDeclarationFragment node) {££
        SimpleName name = node.getName();
        this.names.add(name.getIdentifier());
        System.out.println(
          "Declaration of '" + name + "' at line" + //
          cu.getLineNumber(name.getStartPosition()));
        return false;
      }
      public boolean visit(SimpleName node) {££
        if (this.names.contains(node.getIdentifier())) {££
          System.out.println(
            "Usage of '" + node + "' at line " +//
            cu.getLineNumber(node.getStartPosition()));
        }
        return true;
      }
    });
  }
}
\end{code}
  \end{adjustbox}
\end{figure}

\Cref{figure:eclipse:automatic} shows the automatically spartanized version of
the this code.

\begin{figure}
  \caption{\label{figure:eclipse:automatic}%
    An automatically spartanized version of
      the \Java program of \cref{figure:eclipse}.
    }
  \begin{adjustbox}{max width=\columnwidth}
\begin{code}[minipage, width=1.22\columnwidth]{JAVA}
public class Test1 {££ // comments and £\kk{import}£ directives omitted for brevity
  public static void main(final String[] £\_\_£) {££
    final ASTParser p = ASTParser.newParser(AST.JLS3);
    p.setSource((
      "public class A {\n" +
      " int i = 9;\n"+ //
      " int j;\n" + //
      " ArrayList<Integer> al = new ArrayList<Integer>();\n" + //
      " j=1000;\n" + //
      "}\n").toCharArray());
    final CompilationUnit u = (CompilationUnit) p.createAST(null);
    u.accept(new ASTVisitor() {££
      Set £\ignore$£$ = new HashSet();
      @Override public boolean visit(final SimpleName ¢) {££
        if (£\ignore$£$.contains(¢.getIdentifier()))
          System.out.println("Usage of '" + ¢ + //
            "' at line " + u.getLineNumber(¢.getStartPosition()));
        return true;
      }
      @Override public boolean visit(final VariableDeclarationFragment f) {££
        final SimpleName ¢ = f.getName();
        £\ignore$£$.add(¢.getIdentifier());
        System.out.println("Declaration of '" + ¢ + //
          "' at line" + u.getLineNumber(¢.getStartPosition()));
        return false; // do not continue to avoid usage info
      }
    });
  }
}
\end{code}
  \end{adjustbox}
\end{figure}
Each of the several wrings applied to obtain \cref{figure:eclipse:automatic}
  reduced at least one of our minimization ends.
At several occasions, cleanup increased these.
Overall, the result of automatic application of spartanization
  is a reduction in the number of lines, words, and characters
  by factors of~$1.28$,~$1.05$, and~$1.24$, respectively.†{Part of this improvement
    is due to cleanup operation that optimizes the use of \kk{import}; our empirical
  study ignores \kk{import}s.}
Evidently spartanization shrinks even pedestrian code such as that of
\cref{figure:eclipse}.

Follow the example to appreciate the automatic spartanization process involved:

\begin{enumerate}
  \item \emph{Cleanup}, adding \kk{final}s and \cc{@Override} annotations,
      and simplifying the convoluted reference to data member \cc{names}.
    \item \emph{Structural spartanization}, whose operation was limited to the
      removal of one pair of redundant curly brackets.
    \item \emph{Nominal spartanization}, for which the spartan toolbox offers these
      wrings:
      \begin{description}
        \item[N1] Renaming of the unused
      parameter \cc{args} to \cc{main($·$)} to the spartan name
      \cc{\_\_}, which means ‟unused” in reminiscence of \Prolog's~‟\cc\_”
      name of unused variables.
    \item[N2] Renaming certain variables to~\cc{¢}. The
      spartan name~\cc{¢} is for the most imminent argument or manipulated
      entity that is not \cc{this}, and reminiscent of \kk{it} of \ML and
        \HyperTalk:
        the variable which is so prevalent in the current piece of code that
        naming it would be waste of words. Stated differently, the
        meaning of a variable named~\cc{¢} should be so clear to the reader that
        naming it would be a waste of words.

      \item[N3] Renaming variable \cc{parser} to~\cc{p}, and variable~\cc{cu}
        to~\cc{u}. In accordance with the \emph{Linux kernel coding style}%
        \urlref{https://www.kernel.org/doc/Documentation/CodingStyle}
        and other style guides nominal spartanization abbreviates short scoped
        variables, locals and parameters to one letter that uniquely identifies
        their type. For example, type \kk{int} is denoted by~\cc{i} and the
        name of short scoped, variable \cc{int index;} is abbreviated to~\cc{i}.

        More generally, the single letter denoting a long type name is defined
        as the first letter in the last word of the component of the type name.
        Variable \cc{parser} of type \cc{ASTParser} is hence renamed~\cc{p},
        and~\cc{u} is new name of variable \cc{cu} of type
        \cc{CompilationUnit}. In the case of containers, such as arrays,
        lists, sets, etc., \textbf{N1} add an ‟s” to the short letter
        denoting the elements' type. As demonstrated in
        \cref{figure:accumulate} above, the short name of an iterable of a
        collections of type~\cc{T} is is thus \cc{tss}.

        Abbreviation is limited to only those cases in which short names
        uniquely identifies the variables and there are not more than four of
        these. Experience shows that only a small minority of the methods is
        excluded by this limitation.
\end{description}
  \end{enumerate}

\Cref{figure:primality}, drawn from a spartan implementation of
utility services\urlref{%
  https://github.com/SpartanRefactoring/spartan/blob/master/src/il/org/spartan/misc/Primes.java},
  further demonstrates \textbf{N3}. In the inner loop of the test for
  primality, there is no need to spend words and mental effort to name the
  candidate divisor. It is sufficient to refer to it by the spartan
  name~\cc{¢}, and no confusion should arise.

\begin{figure}
\caption{\label{figure:primality}
  Spartan functions to test for primality†{https://github.com/SpartanRefactoring/spartan}
 }
\begin{Code}{JAVA}{il.org.spartan.misc.Primes＃isPrime}
/** Tests for primality.
  * @param ¢ candidate to be tested
  * @return <code><b>true</b></code> <i>iff</i> the parameter is prime. */
public static boolean isPrime(final int ¢) {££
  return ¢ < -1 && isPrime(-¢) // deal with negative values
      || ¢ > 1 && isPrime¢(¢); // any integer >= 2
}
private static boolean isPrime¢(final int i) {££
  assert i >= 2;
  for (int ¢ = 2; ¢ * ¢ <= i; ++¢)
    if (i ％ ¢ == 0)
      return false;
  return true;
}
\end{Code}
\end{figure}

Note that the single parameter to function \cc{isPrime($·$)} can safely named
‟\cc{¢}”, since the lexical scope in which it is defined (function
\cc{isPrime($·$)}) does not include any other bindings.

In contrast, the single parameter to auxiliary \kk{private} function
\cc{isPrime¢($·$)} must be named ‟\cc{i}”, since its scope includes yet another
binding: That of some name to the loop variable.

Confusion does not rise in naming the loop variable~‟\cc{¢}” since the name
\emph{always} refers to the most recently defined variable, i.e., the one that
occurs last in the most inner lexical scope.

\Cref{figure:free}, drawn from a spartan implementation of
\Prolog\urlref{https://github.com/yossigil/Protolog}, demonstrates one nominal wring
from the spartan toolbox:
\begin{description}
\item[N4] employ the spartan name~‟\cc{\$}” for
  the \emph{single} variable that represents the function's result.†{the
    name~‟\cc{\$}” is borrowed from many DSLs, particularly of regular
  expressions and languages, in which it denotes the concept of termination.}

  The automatic wring heuristic for identifying the ‟result variable”
  by running a tournament between legible candidates result variable,
  abstaining in cases of ties and vacuous matches.
\end{description}

\begin{figure}
  \caption{\label{figure:free}%
    Spartan function to test for the existence of free variables in a
    symbolic-expression, such as those of \protect\Prolog.
  }
\begin{Code}{JAVA}{\scriptsize\texttt{il.org.spartan.protolog.Variable＃freeVariables}}
default Set<Variable> freeVariables() {££
  final Set<Variable> £\ignore$£$ = new LinkedHashSet<>();
  if (isVariable())
   £\ignore$£$.add((Variable) this);
  else
    for (final Term ¢ : this)
     £\ignore$£$.addAll(¢.freeVariables());
  return £\ignore$£$;
}
\end{Code}
\end{figure}

\subsection{Structural spartanization}
\label{section:wrings}

\newlength\ruleLength

One can also note that \cref{figure:free} demonstrates
  a structural wring that puts first the shortest branch of
  an \kk{if}, at the price of negating the conditional.
However, the number of structural wrings is too large to enumerate and
demonstrate all here. The following categorization provides a summary:

\begin{description}
  \item[S0] \emph{Null impact elimination.} The toolbox contains wrings to make
    trivial simplifications of computation whose effect is null. Examples
    include comparison with \kk{true} (always yielding the compared value),
    use of unary ‟\cc{+}”, addition of~\cc{0}, multiplication by~\cc{1}, a
    conjunction with a \kk{true} in it, disjunction with \kk{false} in it, concatenation
    with the empty string (\cc{""}), etc.
    Nullary computation is not frequent in actual code, but it often generated
    out of other, more complicated wrings.

  \item[S1] \emph{Removal of syntactic baggage.}
    Syntactic baggage is keywords and other language tokens,
     whose presence does not contribute to the code semantics.
    In other words, they are safe to remove while preserving meaning.
    Other than the famous braces around a singleton statement,
    the spartan toolbox includes wrings to remove redundant modifiers,
    such as \kk{final} (when present on \kk{private} methods) \kk{abstract}
    (when present on \kk{interface}s), spurious \kk{super}\cc{()} calls, redundant
    semicolon at the of initialization lists, redundant calls to
    \cc{toString()} of objects involved in string concatenation, etc.

Transformation rules are a convenient shorthand for specifying wrings, e.g.,
rules\vspace{-3ex}

  {\scriptsize
      \begin{align}
        & \begin{multlined}[c][0.5\columnwidth]
      \text{\cc{\kk{if}~($C$)~\kk{return}~$E$;~\kk{else}~$S$;}} ⇒⏎
        \text{\cc{\kk{if}~($C$)~\kk{return}~$E$;~$S$;}}
      \end{multlined}
⏎
        & \text{\cc{\kk{if}~($C$)~$S$;~\kk{else}~;}} ⇒ \text{\cc{\kk{if}~($C$)~$S$;}}⏎
        & \text{\cc{\kk{if}~($C$)~;~\kk{else}~$S$}} ⇒ \text{\cc{\kk{if}~(!$C$)~$S$;}}⏎
        & \text{\cc{\kk{while}~($C$)~❴❵}} ⇒ \text{\cc{\kk{while}~($C$)~;}}
      \end{align}
    } \vspace{-3ex}

\noindent remove redundant \kk{else} branches, an empty main branch of
conditional, and convert an empty~\cc{❴}…\cc{❵} pair to~\cc{;}. Wrings however
may be more complicated: removing an empty \kk{else} branch may change
semantics if attention is not paid to occasions in which the remaining \kk{if}
attaches, as a result of the transformation, to a different \kk{else} branch.

\item[S2] \emph{Factorization with the distributive propety.}
  The distributive property occurs in code for many more occasions
  than plain arithmetic, including Boolean algebra, assignments, and
  conditionals. The structural wrings in the toolbox that take
  advantage of this property are:

  {\scriptsize
    \begin{align}
      & \text{\cc{$A$*$B$ +~$C$*$B$}} ⇒ \text{\cc{($A$+$C$)~*~$B$}},⏎
      & \text{\cc{$B$*$A$ +~$B$*$C$}} ⇒ \text{\cc{$B$~*~($A$+$C$)}},⏎
      & \text{\cc{$A$ ＆＆~$B$ ||~$C$ ＆＆~$B$}} ⇒ \text{\cc{($A$ ||~$C$) ＆＆~$B$}},⏎
      & \text{\cc{$A$ ||~$B$ ＆＆~$B$ ||~$B$}} ⇒ \text{\cc{$A$ ＆＆~$C$ ||~$B$}},⏎
      & \text{\cc{\kk{if}~($C₁$)~$S$; \kk{if}~($C₂$)~$S$;}} ⇒ \text{\cc{\kk{if} ($C₁$ ＆＆~$C₂$)~$S$;}}⏎
      & \begin{multlined}[c][0.5\columnwidth]
       \text{\cc{\kk{if}~($C₁$)~\kk{if}~($C₂)$~$S$; \kk{if}~($C₂$)~$S$;}} ⇒⏎
       \text{\cc{\kk{if} ($C₁$ ||~$C₂$)~$S$;}}
     \end{multlined}⏎
      & \begin{multlined}[c][0.5\columnwidth]
     \text{\cc{\kk{if}~($C$)❴$S₁$;$S₂$❵~\kk{else}~❴$S₁$;~$S₃$❵}} ⇒⏎
     \text{\cc{$S₁$;\kk{if}~($C$)~$S₂$;~\kk{else}~$S₃$}}
     \end{multlined}⏎
      & \begin{multlined}[c][0.5\columnwidth]
       \text{\cc{\kk{if}~($C$)❴$S₁$;$S₃$❵~\kk{else}~❴$S₂$;~$S₃$❵}} ⇒ \\
      \text{\cc{\kk{if}~($C$)~$S₁$;~\kk{else}~$S₂$};~$S₃$}
     \end{multlined}⏎
      & \text{\cc{$V₁$ =~$X$;~$V₂$ =~$X$}} ⇒ \text{\cc{$V₁$ =~$V₂$ =~$X$}}⏎
      \label{eq:ternary}
      & \text{\cc{$C$~? f($X$) : f($Y$)}} ⇒ \text{\cc{f($C$~?~$X$:~$Y$)}}⏎
      & \begin{multlined}[c][0.5\columnwidth]
        \text{\cc{\kk{if}~($C$)~\kk{return}~$E₁$;~\kk{else}~\kk{return}~$E₂$}} ⇒⏎
        \text{\cc{\kk{return}~$C$~?~$E₁$~:~$E₂$;}}
     \end{multlined}
  \end{align}
}

Worthy of notice in this partial list are symmetries of the distributive property: right and
left distribution (as in \kk{if}), the duality of operators (\cc{＆＆} can
be replaceable by \cc{||}, as long as the mirror replacement of
\cc{||} by \cc{＆＆} is carried out collaterally), etc.

\item[S3] \emph{Ternarization.} The third kind of non-trivial wrings are those
that attempt to change an \kk{if} statement into a ternary expression.
The basic transformation rule is:\vspace{-3ex}

{\scriptsize
    \begin{align}
& \text{\cc{\kk{if}~($C$)~$S$;~\kk{else}~$S₂$;}} ⇒ \text{\cc{$C$~?~$S₁$~:~$S₂$}}
    \end{align}
  }\vspace{-3ex}

\noindent except that more caution must be applied before applying this transformation:
\begin{enumerate}
  \item Notice that the original code is a statement, while the transformed is
        an expression. The transformation can only work if the distributive rule
        \cref{eq:ternary} can be applied next to to can further push down the ternary
        operator onto~$S₁$ and~$S₂$ whereby making the transformed into a statement.
  \item Since in many the \kk{else} branch of a wring is missing, the
    spartanization may need to complete it, by transformation rules such as:\vspace{-3ex}

        {\scriptsize
            \begin{multline*}
              \text{\cc{\kk{if}~($C$)~\kk{return}~$E₁$;\kk{return}~$E₂$;}} ⇒⏎
              \text{\cc{\kk{if}~($C$)~\kk{return}~$E₁$;\kk{else} \kk{return}~$E₂$;}}.
            \end{multline*}
          }\vspace{-3ex}

        Observe that the above transformation rule is not a wring: It
        increases the number of tokens, to make the input more amenable to
        ternarization.
\end{enumerate}

\item[S4] \emph{Canonic form.} Wrings of this kind to bring the
  code into a more canonical form, by sorting by length terms of addition
  factors of multiplication, pulling out multiplication by \cc{-1}, and
   even pushing down logical negation using de-Morgan
   laws (possibly flipping comparison operations when necessary), etc.

   Also included in this group is the wring that converts \cc{x.toString()} to
   \cc{""~+~x}, a wring that favors, whenever possible, postfix increment and
   decrement operations to their prefix version, and more.

\item[S5] \emph{Inlining and scope reduction.}
  The final kind of structural wrings is concerned with elimination of
  variables through inlining, and when this is not possible, trying to reduce
  their scope. A variable is inlined if it used only once, or if it its
  computation involves no side effects, and its inlining does not increase code
  size.

  If a variable cannot be inlined, then there are wrings that try to bring its
  definition as close as possible to its use. If several variables compete for
  the closest position to a certain definition, then the \textit{life and size
  of stacked context} minimization end arbitrates.
\end{description}
