The spartan programming style tries to achieve terse, clear and modular code,
by \textit{simultaneous} minimization of these measures:
\begin{enumerate}
  \item \textit{code size,} which here means all of number of lines, number of
        characters, \emph{and}, number of language tokens;
  \item \textit{vertical complexity,} e.g., the number of lines in each
        method;
  \item \textit{horizontal complexity,} including, the number of parameters to a
        module (method or generic class), \emph{and} the level of nesting of
        control commands, \kk{if}, \kk{while}, \kk{switch}, etc. However,
        horizontal complexity does not concern line length, which is generally
        discarded by spartanization.
  \item \textit{control complexity,} which is the total number of control
        commands in the code.
  \item \textit{variability,} which means minimizing visibility, ability to
        change, lifetime, and scope of variables, just as their number.
        This means the introduction of \kk{final} whenever possible,
        variable inlining, preferring local variables to parameters, parameters
        to fields, and fields to \kk{static} fields, careful use of
        \cc{public}, etc.
  \item \textit{exploitation of environment,} which means the number of
    distinct identifiers (of fields, methods, etc.) used in any module.
  \item \textit{life and size of stacked context,} which is the most intricate of the
        spartan minimization ends.

        To understand what terms stacked context and its life mean, consider
        this code snippet

\begin{code}[minipage,width=54ex]{java}
ThingTwo ii = new ThingTwo();
ii.wreck(house);
System.out.println(ii);
ThingOne i = new ThingOne(); // Stack context of £\cc{ii}£
System.out.println(i); // Context of £\cc{ii}£ still stacked
i.wreck(house); // Stacked still£…£
System.out.println(i); // Still!
cat.join(i, ii); // Finally: recalling context of £\cc{ii}£.
  \end{code}
  The last line in this snippet joins the three objects,
  \cc{cat},~\cc{i}, and \cc{ii}. The four preceding lines prepare
  and print object~\cc{i}.

  Object~\cc{i} is prepared and printed in the remainder, i.e., the first three
  lines of the snippet. The fact that it existed is stacked then during the
  preparation of~\cc{i}, and restored only at the last line.

  By swapping the order of construction, we obtain code in which the stacked is
  a bit shorter,~\cc{i} instead of~\cc{ii}, and in a linear read of the
  program, it is stacked for three lines rather than four.

\begin{code}[minipage,width=54ex]{java}
ThingOne i = new ThingOne();
System.out.println(i);
i.enter(house);
System.out.println(i);
ThingTwo ii = new ThingTwo(); // Stack context of £\cc{i}£.
ii.enter(house); // Context of £\cc{i}£ still stacked.
System.out.println(ii); // Context is stacked still.
cat.join(i, ii); // Recalling context of £\cc{ii}£.
  \end{code}
\end{enumerate}

\subsection{Rationale}
\label{section:rationale}
To an extent, these minimization ends are reformulation of traditional belief
on software: that software should be organized in short cohesive modules whose
code depends on few globals, and is frugal in its use of control. Conversely,
complaints on code quality, include deep and complex nesting \kk{if}s and
\kk{for}s, endless parameters' lists, piles of global variables and many
methods and classes that should be understood before understanding any given
method, etc.

Also, the end of minimizing life and size of saved contexts captures in it
principles such as early \cc{throw}, \cc{return} and \cc{break} (from loops) on
errors, ordering by increasing length to increase readability, and also the
practice of placing at first the short branch of an \cc{if} conditional, etc.

Unlike other coding guidelines, spartanization prescribes a (semi-automatic)
uncompromising process by which code can be spartanized. The central novelty
therefore in spartan programming is not in these numerical minimization ends,
but in the \emph{manner}, \emph{extent}, and \emph{automation} of the quest
for their optimization. The last three \emph{emphasized} words make the titles
of \cref{section:manner}, \cref{section:extent}, and \cref{section:automation}
ahead.

\subsection{Manner of application}
\label{section:manner}
The spartanization process is governed by the spartan
\emph{toolbox}, which is a collection of many (currently around sixty)
structural and nominal wrings. Each \emph{wring} is a refactoring that does
not degrade quality as measured by any of minimization ends: LOC, number of
tokens, nesting level, size of stacked scope, etc., while improving on at least
one of them.

A \emph{structural wring} is a wring that modifies the structure of the code,
A simple structural wring is the one removing
useless \kk{abstract} and \kk{public} modifiers from
declarations made withing an \kk{interface}.
The application of a chain of structural wrings converts
\begin{lcode}{JAVA}
if (f() == true) {££
  return false;;
} else {££
  return true;;
}
\end{lcode}
\noindent into
\begin{lcode}{JAVA}
return !f();
\end{lcode}
\noindent
This chain includes a wring to remove redundant curly brackets and one for the
removal of redundant semicolons.
Also involved is a wring for the conversion of an \kk{if} into to a
\emph{ternary} expression (one employing the operator~\cc{$·$?$·$:$·$}), and a
wring simplification of ternary expressions involving boolean literals.

In contrast, a \emph{nominal wring} is a wring that does not modify the
code itself, but renames some entities in it, most particularly, variables.
For example, the toolbox includes a nominal wring to convert the name of the
variable returned by a method, to the one character identifier ‟\cc{\$}”,
which is the short spartan name for result.

If none of the wrings in the toolbox is applicable to the code, then
spartanization has reached a (local) optimum. Otherwise, code spartanization
proceeds by selecting one such wring and continuing with the code obtained
after applying this wring.

This process can be automated or carried out interactively. Many of the wrings
are implemented as part of an open source spartan refactoring Eclipse
plugin\urlref{https://github.com/SpartanRefactoring/spartan-refactoring} which
makes it possible for programmers to apply much of it.

In addition to wrings, spartanization may use
\begin{itemize}
    \item cleanup by external tools, specifically, Eclipse's cleanup operation,
      to tasks such as minimizing variability as planting \kk{final} modifier
      whenever possible, removing unused variables and methods, removing
      unnecessary parenthesis, etc.
    \item user intervention for appropriate
        clever method extraction, and other modular restructuring to
        minimize e.g., exploitation of environment.
\end{itemize}
Naturally, size increases with the addition of \cc{final}s; other cleanups, such
as the automatic addition of \cc{@Override} annotation may increase size as well.
Also, typically method extraction and other modular transformations increases
code size, be it measured in lines, tokens, characters or bytes.

Thus, there are four components to the spartanization process:
\emph{\textbf{(i)}} structural,
\emph{\textbf{(ii)}} nominal,
\emph{\textbf{(iii)}} cleanup, and,
\emph{\textbf{(iv)}} modular.
Current technology can automate all but the last component;
automation of method extraction requires more research,
paying attention to current state of the art \matteo~\cite{%%
    we should have many citations
    somewhere can you please add some citations
}.
This section is concerned with the full process of spartanization.
The empirical \cref{section:initial} below investigates how structural and
nominal spartanizations contribute to the naturalness of code.

\subsection{Extent of application}
\label{section:extent}
An underlying principle is not only that the minimization of
the above ends matters, but also that \emph{nothing else matters}.
In other words, wrings are applied repeatedly, with explicit disregard
to any other extent†{%
  In the Spartan's words: ‟\textit{As far as this can reach}.” K. Agesilaus the
  great (\textsl{being asked for the extent of Sparta's border, while
  holding his spear}).
}.

Heavily spartanized code is often quite different than the original. A case in
point can be found in generic class \cc{C0}, defined by the programmer to
include only instance field \cc{inner} of the generic type parameter.

\begin{figure}[H]
  \caption{A generic class representing a cell, along with its Eclipse
  automatically generated methods (28 lines, 94 words, and 649 characters).}
    \label{figure:cell0}
    \begin{adjustbox}{max width=\columnwidth}
% VIM: /begin/+,/end/-!wc
\begin{code}[minipage, width=1.25\columnwidth]{JAVA}
public class C0<T> {££
  private T inner;
  public C0(T inner) {££
    super();
    this.inner = inner;
  }
  public int hashCode() {££
    final int prime = 31;
    int result = 1;
    result = prime * result + ((inner == null) ? 0 : inner.hashCode());
    return result;
  }
  public boolean equals(Object obj) {££
    if (this == obj)
      return true;
    if (obj == null)
      return false;
    if (getClass() != obj.getClass())
      return false;
    C0 other = (C0) obj;
    if (inner == null) {££
      if (other.inner != null)
        return false;
    } else if (!inner.equals(other.inner))
      return false;
    return true;
  }
}
\end{code}
\end{adjustbox}
\end{figure}

\Cref{figure:cell0} portrays this class along with function members
automatically generated by Eclipse: a constructor and the trivial methods
\cc{equals($·$)} and \cc{hashCode()} methods.

Compare this figure to its spartanized terse version in \cref{figure:cell1}.

\begin{figure}[H]
  \caption{A spartanized version of the \Java class in \cref{figure:cell0}
    automatically generated methods (16 lines, 70 words and 424 characters).}
    \label{figure:cell1}
    \begin{adjustbox}{max width=\columnwidth}
% VIM: /begin/+,/end/-!wc
\begin{code}[minipage, width=1.25\columnwidth]{JAVA}
public class C1<T> {££
  private final T inner;
  public C1(T inner) {££
    this.inner = inner;
  }
  public int hashCode() {££
    return 31 + ((inner == null) ? 0 : inner.hashCode());
  }
  public boolean equals(Object ¢) {££
    return ¢ == this || //
      ¢ != null && getClass() == ¢.getClass() && equals((C1) ¢);
  }
  private boolean equals(C1 ¢) {££
    return inner == null ? ¢.inner == null : inner.equals(¢.inner);
  }
}
\end{code}
\end{adjustbox}
\end{figure}

Evidently, spartanization has removed all conditionals, replacing these with
the ternary operator and the short-circuit operators, ‟\cc{\textbar\textbar}”
and ‟\cc{＆＆}”. Spartanization also abbreviated \cc{obj} to~\cc{o} and then
renamed it to~\cc{¢}, eliminated the spurious \cc{\kk{super}()} call in the
constructor, as well as the two variables use in \cc{hashCode()}, turning the
function into a single expression.

The resulting code is evidently shorter, and not as nested. Arguably, the code
is also easier explain and understand: For example, function \cc{equals(Object
¢)} in the figure is described by its own code, while relying on the
understanding of the Boolean operators

\begin{quote}\itshape\scriptsize
  If the sent parameter is the same as \cc{this}, then equality is guaranteed.
  Otherwise, the parameter must not be \kk{null}, and must be of the same class
  of \kk{this}. Further, the parameter must also be of the same as class as
  \kk{this}, and equal to \kk{this} also as an instance of this class.
\end{quote}

Notice though that line length, which is not optimized by the wrings, suffered
a bit. We do have fewer lines, but the average number of characters in them
increased from 23 characters to 26.5. Also, the maximal line length increased
from 71 characters to 81. This last increase is due though due to the
extraction of a \kk{private} version of \cc{equals($·$)}, which is carried
out manually, at user's discretion.

\subsection{Automation}
\label{section:automation}
Consider the \Java program presented in \cref{figure:eclipse}, drawn from the
Eclipse JDT Tutorial series\urlref{%
http://www.programcreek.com/2011/01/a-complete-standalone-example-of-astparser},
but slightly amended for brevity.

\begin{figure}[H]
  \caption{\label{figure:eclipse}%
    A complete standalone example of using class \cc{ASTParser}, drawn
    from the Eclipse JDT Tutorial Series, abbreviated and reformatted.}
    \begin{adjustbox}{max width=\columnwidth}
      \begin{code}[minipage, width=1.13\columnwidth]{JAVA}
public class Test0 {££ // comments and £\kk{import}£ directives omitted for brevity
  public static void main(String args[]) {££
    ASTParser parser = ASTParser.newParser(AST.JLS3);
    parser.setSource((
      "public class A {\n" +
      " int i = 9;\n"+ //
      " int j;\n" + //
      " ArrayList<Integer> al = new ArrayList<Integer>();\n" + //
      " j=1000;\n" + // 
      "}\n").toCharArray());
    parser.setKind(ASTParser.K£\_£COMPILATION£\_£UNIT);
    CompilationUnit cu = (CompilationUnit) parser.createAST(null);
    cu.accept(new ASTVisitor() {££
      Set names = new HashSet();
      public boolean visit(VariableDeclarationFragment node) {££
        SimpleName name = node.getName();
        this.names.add(name.getIdentifier());
        System.out.println(
          "Declaration of '" + name + "' at line" + //
          cu.getLineNumber(name.getStartPosition()));
        return false;
      }
      public boolean visit(SimpleName node) {££
        if (this.names.contains(node.getIdentifier())) {££
          System.out.println(
            "Usage of '" + node + "' at line " +//
            cu.getLineNumber(node.getStartPosition()));
        }
        return true;
      }
    });
  }
}
\end{code}
  \end{adjustbox}
\end{figure}

\Cref{figure:eclipse:automatic} shows the automatically spartanized version of
the this code.

\begin{figure}
  \caption{\label{figure:eclipse:automatic}%
    An automatically spartanized version of
      the \Java program of \cref{figure:eclipse}.
    }
  \begin{adjustbox}{max width=\columnwidth}
\begin{code}[minipage, width=1.22\columnwidth]{JAVA}
public class Test1 {££ // comments and £\kk{import}£ directives omitted for brevity
  public static void main(final String[] £\_\_£) {££
    final ASTParser p = ASTParser.newParser(AST.JLS3);
    p.setSource((
      "public class A {\n" +
      " int i = 9;\n"+ //
      " int j;\n" + //
      " ArrayList<Integer> al = new ArrayList<Integer>();\n" + //
      " j=1000;\n" + // 
      "}\n").toCharArray());
    final CompilationUnit u = (CompilationUnit) p.createAST(null);
    u.accept(new ASTVisitor() {££
      Set £\ignore$£$ = new HashSet();
      @Override public boolean visit(final SimpleName ¢) {££
        if (£\ignore$£$.contains(¢.getIdentifier()))
          System.out.println("Usage of '" + ¢ + //
            "' at line " + u.getLineNumber(¢.getStartPosition()));
        return true;
      }
      @Override public boolean visit(final VariableDeclarationFragment f) {££
        final SimpleName ¢ = f.getName();
        £\ignore$£$.add(¢.getIdentifier());
        System.out.println("Declaration of '" + ¢ + //
          "' at line" + u.getLineNumber(¢.getStartPosition()));
        return false; // do not continue to avoid usage info
      }
    });
  }
}
\end{code}
  \end{adjustbox}
\end{figure}
Each of the several wrings applied to obtain \cref{figure:eclipse:automatic}
  reduced at least one of our minimization ends.
At several occasions, cleanup increased these.
Overall, the result of automatic application of spartanization
  is a reduction in the number of lines, words, and characters
  by factors of~$1.28$,~$1.05$, and~$1.24$, respectively.†{Part of this improvement
    is due to cleanup operation that optimizes the use of \kk{import}; our empirical
  study ignores \kk{import}s.}
Evidently spartanization shrinks even pedestrian code such as that of
\cref{figure:eclipse}.

Follow the example to appreciate the automatic spartanization process involved:

\begin{enumerate}
  \item \emph{Cleanup}, adding \kk{final}s and \cc{@Override} annotations,
      and simplifying the convoluted reference to data member \cc{names}.
    \item \emph{Structural spartanization}, whose operation was limited to the
      removal of one pair of redundant curly brackets.
    \item \emph{Nominal spartanization}, including these operations:
      \begin{description}
        \item[N1] Renaming of the unused
      parameter \cc{args} to \cc{main($·$)} to the spartan name
      \cc{\_\_}, which means ‟unused” in reminiscence of \Prolog's~‟\cc\_”
      name of unused variables.
    \item[N2] Renaming certain variables to~\cc{¢}. The
      spartan name~\cc{¢} is for the most imminent argument or manipulated
      entity that is not \cc{this}, and reminiscent of \kk{it} of \ML and
        \matteo HyperCard~\cite{there:must:be:some:citation:in:our:huge:bib:repository}:
        the variable which is so prevalent in the current piece of code that
        naming it would be waste of words. Stated differently, the
        meaning of a variable named~\cc{¢} should be so clear to the reader that
        reader, that naming it would be a waste of words.

      \item[N3] Renaming variable \cc{parser} to~\cc{p}, and variable~\cc{cu}
        to~\cc{u}. In accordance with the \emph{Linux kernel coding style}%
        \urlref{https://www.kernel.org/doc/Documentation/CodingStyle}
        and other style guides nominal spartanization abbreviates short scoped
        variables: locals and parameters to one letter that uniquely identifies
        their type. For example, type \kk{int} is denoted by~\cc{i} and the
        name of short scoped, variable \cc{int index;} is abbreviated to~\cc{i}.

        More generally, the single letter denoting a long type name is defined
        as the first letter in the last word of the component of the type name.
        Variable \cc{parser} of type \cc{ASTParser} is hence renamed~\cc{p},
        and~\cc{u} is new name of variable \cc{cu} of type \cc{CompilationUnit}.

        Abbreviation is limited to only those cases in which one letter
        uniquely identifies the variables and there are not more than four of
        these. Experience shows that only a small minority of the methods is
        excluded by this limitation.

\end{description}
  \end{enumerate}

\Cref{figure:primality}, drawn from a spartan implementation of
utility services\urlref{%
  https://github.com/SpartanRefactoring/spartan/blob/master/src/il/org/spartan/misc/Primes.java},
  further demonstrates \textbf{N3}. In the inner loop of the test for
  primality, there is no need to spend words and mental effort to name the
  candidate divisor. It is sufficient to refer to it is by the spartan
  name~\cc{¢}, and no confusion should arise.

\begin{figure}
\caption{\label{figure:primality}
  Spartan functions to test for primality†{https://github.com/SpartanRefactoring/spartan}
 }
\begin{Code}{JAVA}{il.org.spartan.misc.Primes＃isPrime}
/** Tests for primality.
  * @param ¢ candidate to be tested
  * @return <code><b>true</b></code> <i>iff</i> the parameter is prime. */
public static boolean isPrime(final int ¢) {££
  return ¢ < -1 && isPrime(-¢) // deal with negative values
      || ¢ > 1 && isPrime¢(¢); // any integer >= 2
}
private static boolean isPrime¢(final int i) {££
  assert i >= 2;
  for (int ¢ = 2; ¢ * ¢ <= i; ++¢)
    if (i ％ ¢ == 0)
      return false;
  return true;
}
\end{Code}
\end{figure}

Note that the single parameter to function \cc{isPrime($·$)} can
safely named ‟\cc{¢}”, since the lexical scope in which it is defined (funtion
\cc{isPrime($·$)}) does not include any other bindings.

In contrast, the single parameter to auxiliary \kk{private} function
\cc{isPrime¢($·$)} must be named ‟\cc{i}”, since its scope includes yet another
binding: That of some name to the loop variable.

Confusion does not rise in naming the loop variable ‟\cc{¢}” since the name
\emph{always} refers to the most recently defined variable, i.e., the one that
occurs last in the most inner lexical scope.

\Cref{figure:free}, drawn from a spartan implementation of
\Prolog\urlref{https://github.com/yossigil/Protolog}, demonstrates one more kind of
nominal spartanization:
\begin{description}
\item[N4] employ the spartan name~‟\cc{\$}” for
  the \emph{single} variable that represents the
  function's result.†{the name ‟\cc{\$}” is borrowed from many DSLs,
    particularly of regular expressions and languages, in which it denotes the
  concept of termination.}

  The automatic wring heuristic for identifying the ‟result variable”
  by running a tournament between legible candidates result variable,
  abstaining in cases of ties and vacuous matches.
\end{description}

\begin{figure}
  \caption{\label{figure:free}%
    Spartan function to test for the existence of free variables in a
    symbolic-expression, such as those of \protect\Prolog.
  }
\begin{Code}{JAVA}{\scriptsize\texttt{il.org.spartan.protolog.Variable＃freeVariables}}
default Set<Variable> freeVariables() {££
  final Set<Variable> £\ignore$£$ = new LinkedHashSet<>();
  if (isVariable())
   £\ignore$£$.add((Variable) this);
  else
    for (final Term ¢ : this)
     £\ignore$£$.addAll(¢.freeVariables());
  return £\ignore$£$;
}
\end{Code}
\end{figure}

\subsection{Structural spartanization}
One can also note that \cref{figure:free} demonstrates
  a structural wring that puts first the shortest branch of a
  an \kk{if}, at the price of negating the conditional.
However, the number of structural wrings is too large to enumerate and
demonstrate all here. The following categorization provides a summary:
\begin{description}
  \item[S1] \emph{Removal of syntactic baggage.}
  Redundant parenthesis and curly brackets. Removing redundant modifiers:
          \kk{final} in private methods. \kk{final} from static methods.
          \kk{abstract} before interface.
          \kk{abstract} before methods in interfaces.
          \kk{final} from all methods in final classes.
          \kk{private} and \kk{static} from everything defined in
                anonymous classes.
  Removing visibility of all members of an interface
  Extra super() calls.

\item[S2]
  Distributive rule of Boolean expressions
  Distributive rule of assignment:
        \begin{code}{JAVA}
a = x;
b = x;
  \end{code}
  becomes
  \begin{code}{JAVA}
a = b = x;
  \end{code}
  Distributive rule of arithmetic.
    Common prefix of If
    Common Suffix of If
    Pull out arithmetical negation
    Use ternary instead of conditionals.
    convert prefix ++ and--into postfix when possible
    Example:
        \begin{code}{JAVA}
x.toString()
  \end{code}
  \begin{code}{JAVA}
"" + x
  \end{code}

\item[S3]
  \emph{Canonic form.}
Use canonical form for the most common expressions, as much as possibile.

    Follow patterns: Pattern: A*x + B
    Sorting by size, but also as per the previous rule.
    De Morgan pushdown logical negation.
    Pullup arirthmetic negation.
    Pushdown ternarizations. For example:
        % Example:
        \begin{code}{java}
a ££? b(x) : b(y) => b(a ££? x: y)
  \end{code}
    Apply the distributive rule on booleans. For instance:
        % Example:
\begin{code}{JAVA}
a && b || c && b => (a || c) && c
  \end{code}
  This is one variant (there are other three).
    More specific first: How should you order X == Y.
        Rule: you start from the more specific and increase specifity, i.e.,
        S(X) > S(Y)
            null/this/true/false
            0, 1, ""
            12, 13.4
            Classes: public, protected, package, private
            Fields: Static fields, Fields,
            parameters,d
            local variables ordered by scope.
            ¢
\item{Inlining}

Spartan programming promote a coding style that do not use many variables,
meaning that it strives to inline instructions instead of storing their results
on variables. The spartanized version of a code not originally written in the
Spartan way, would probably see many of the included variable deleted whenever
and wherever it is possible.

The idea behind this approach is to reduce the cognitive burden of the
developers, either in case of whom is coding who has to spent time and effort
in finding effective names, either in the case of a reader who need to put some
effort to figure out what is the meaning of a variable, starting from its name.

Since variables change, it needs to be sure that it happens when it is supposed
to do. Moreover it is needed to associate a role to a variables, so that the
code that reads that variable can understand and appreciate it and figure out
the list of location where it may be read (CHANGE).

These are some technique for variable elimination.

\item{Variable Inlining}

The following is a self explanatory example of inlining:

\begin{code}{JAVA}
double a = p.area();
return a;
\end{code}

becomes

\begin{code}{JAVA}
return p.area();
\end{code}

\item{Early returns}

Another technique for variable elimination is the early return and it consist
in returning the result of a computation as soon as it is available, instead of
storing it in a variable (and then returning it). An example of early return
is reported in the following code.

\begin{code}{JAVA}
private boolean isKeyword(String token, String[] keywords) {££
    for (int i = 0; i < keywords.length; i++)d
        if (token.equals(keywords[i]))
            return true;
    return false;
}
\end{code}

Using \kk{forech} construct available in several langues it is possible to
avoid the index (in those case in which there are no instructions to access to
it).
\begin{code}{JAVA}
private boolean isKeyword(String token, String[] keywords) {££
    for (final String element : keywords)
        if (element.equals(token))
            return true;
    return false;
}
\end{code}
The same result can be obtained using the some construct to loop over
collections, preferred instead of the arrays, without the use of the
\cc{Iterator} class, as in the previous versions of Java.

% With the early return it becomes:
% \begin{code}{JAVA}
% private ResultRenderer getRenderer() throws InstantiationException,
% IllegalAccessException, ClassNotFoundException {££
% returnᵣesultRenderer != null ? (ResultRenderer)
% Class.forName(ᵣesultRenderer).newInstance() : DefaultResultRenderer();
% }
% \end{code}

\item{Control simplification}
Spartan programming foster the use of the ternary operator over the
\kk{if-else} construct. This way the implementation of the factorial
\begin{code}{JAVA}
int factorial(int n) {d
    if (n <= 1)
        return n;
    else
        return n * fact(n - 1);
}
\end{code}
becomes
\begin{code}{JAVA}
int factorial(int n) {££
  return n <= 1 ££? n : n * fact(n - 1);
}
\end{code}
in this case in a return statement that allows inlining of the instruction.

\item{String simplification Techniques}

    String transformations
    instead of \cc{££.toString()} use \cc{"" +}
    x.equals(“a”) -> “a”.equals(b)
    Auto insert “”

\item{Miscellaneous Techniques}

Here we report a series of techniques that not fall expressly in one of the
previous category.

    Favor prefix operators over postfix ones.
    In expressions order the operator according to their length (shortest
        come first) or specificity (more specific come first).
    Associative rule of ifs:
        \begin{code}{JAVA}
if (a) if (b) x;
  \end{code}
  \begin{code}{JAVA}
if (a && b) x
  \end{code}
  % Associative rule of ifs: if (a)
  % \begin{code}{JAVA}if (b) x;\end{code}
  % \begin{code}{JAVA}if (a && b) x\end{code}
  \begin{code}{JAVA}
if (this == null) return super();
  \end{code}

  INLINING??

      Off load exceptional cases quickly.
      inline single use of variables.
      Inline multiple use of variables: if 1) result is shorter and 2
) the expression has no side effects.
      Pseudo inlining with initializers.
      Scope:

  Scope:

      Move into for
      Move into try
      Move next to use

  Variability

      Variability (add final when possible.)
      Variables (inlining)
      What’s first

  Sorting

      Most external escape
      Shortest: 2*112*a*ab
      Least specific

  Canonical ordering

      Simplificatons

              Algebraic simplifications
              Logical simplification
              Literal simplification
              Arithmetical simplification

      Patterns: 2 * x + 1d
      Pushdown:
      Logical Negation
      Arithmetical Negation
      Auto distributive
      Repeated deterministic expressions
      Auto

              Auto Collect
              Auto insert/remove 0+ in ternarization.
              Auto insert/remove 1*
              Auto add “” +

  \subsection{Renaming}

      In constructors: Arguments to corresponding field names
      In fields: to canonical instance name or pluralized
      In getters: Change name to fieldName if it is a getter.
      In Methods
      In local variables:
      return variable to \$

    Change argument to one single case letter
        % In world amalgams, use the first letter of the last word.
        % Multiplicities

            Deal with multiplicities of arrays
            Deal with multiplicities of collections
            Deal with nested multiplicities

    Change return type of void to ClassName and return this

            Single argument:

                    To \_\_ if unused
                    To \$ in case it is returned
                    To fieldName in case it is a setter
                    To ¢ in case method has no inner methods and is not a
                        setter

                    Any number of arguments:
                    To \$ in case it is returned
                    To \cc{\_\_}
                        if it is unused and documented as such

                % Change argument to one single case letter
                % In world amalgams, use the first letter of the last word.
            Deal with multiplicities

%
% Ternarize
% Early return
% Example:
% \begin{code}{JAVA}
% @SuppressWarnings("unused") private
% void earlyReturn(int a) {££
% if (new Random().nextInt() <= 3) {££
% earlyReturn(12);
% earlyReturn(124);
% } else {££
% earlyReturn(4);
% earlyReturn(5);
% earlyReturn(44);
% }
% }
% \end{code}
%

\Cref{figure:eclipse:spartan} shows the spartanized version of the program in
the \cref{figure:eclipse}. Employed were nominal spartanization, e.g., renaming
variable \cc{names} to~\cc{\$}, structural spartanization, e.g., for the
removal of braces, and modularization.

The product of external cleanup, which in this case amounts to adding
\kk{final}s and \kk{@Override}, is not included in this example.

The main difference between the figures is due to method extractions, conducted
manually. Auxiliary \kk{private} function \cc{main()} minimizes exploitation of
scope by denying access to the \cc{args} argument of function \cc{main}.
Function \cc{makeCompilationUnit()} takes advantage of the fact that variable
\cc{parser} is only used in a limited section of the \kk{public} function
\cc{main(String[] args}, etc.

Examining the body of the anonymous class (that one that \cc{extends}
\cc{ASTVisitor}) we see some more extracted methods. The reduction in clutter
due to spartanization makes it possible to identify another spot of useful
method extraction.

\begin{figure}
  \caption{Spartanized version including structural, nominal, modular, but
    not cleanups, of the \Java program in \cref{figure:eclipse}.}
  \label{figure:eclipse:spartan}
  \begin{adjustbox}{max width = \columnwidth}
\begin{code}[minipage, width=1.13\columnwidth]{JAVA}
public class Test {££ // comments and £\kk{import}£ directives omitted for brevity
  public static void main(String[] £\_\_£) {££ main(); }
  private static void main() {££
    CompilationUnit u = makeCompilationUnit();
    u.accept(new ASTVisitor() {££
      Set £\ignore$£$ = new HashSet();
      public boolean visit(SimpleName ¢) {££
        note(¢);
        return true;
      }
      public boolean visit(VariableDeclarationFragment ¢) {££
        collect(¢.getName());
        return false;
      }
      void note(SimpleName ¢) {££
        if (£\ignore$£$.contains(¢.getIdentifier()))
          System.out.println("Usage of '" + ¢ + //
            "' at line " + u.getLineNumber(¢.getStartPosition()));
      }
      void collect(SimpleName ¢) {££
        £\ignore$£$.add(¢.getIdentifier());
        System.out.println("Declaration of '" + ¢ + //
          "' at line" + u.getLineNumber(¢.getStartPosition()));
      }
    });
  }
  private static CompilationUnit makeCompilationUnit() {££
    return (CompilationUnit) makeParser().createAST(null);
  }
  private static ASTParser makeParser() {££
    ASTParser £\ignore$£$ = ASTParser.newParser(AST.JLS3);
    £\ignore$£$.setSource(
      "public class A {\n" +
      " int i = 9;\n"+ //
      " int j;\n" + //
      " ArrayList<Integer> al = new ArrayList<Integer>();\n" + //
      " j=1000;\n" + // 
      "}\n" + //
      .toCharArray()
);
    £\ignore$£$.setKind(ASTParser.K£\_£COMPILATION£\_£UNIT);
    return £\ignore$£$;
  }
}
\end{code}
  \end{adjustbox}
\end{figure}

% Yet another, further simplified version of the code of \cref{figure:eclipse} shows
% up in \cref{figure:eclipse:extract}. This figure depicts only the anonymous
% class found in previous figures, but with extra method extracted to simplify
% the code. Of course, a demand for clever method extraction can not be part of a
% strucured We argue that the
% process of spartanization helped in
% this case to highlight

% However, being in a certain sense, counter intuitive, in order to apply
% Spartanization on their working routines, the developers need to respect a firm
% discipline. From a certain standpoint, Spartan Programming might be seen as a
% list of code style prescription, but it would just scratch the surface. It is
% far more than that, since it
%
% Being minimized, spartanized code might be less readable that the original.
% This is … Spartan programming is not directly concerned with readability, at
% least not in its subjective and cultural-dependent sense. In fact, spartan
% programs will bring much misery to anyone preferring long, verbose programs.
%
% Spartan programming prescribes, a careful use of the variables, stressing the need
% to inline variables that are used only once and emphasizing the use of foreach loops
% in languages implementing it. Variables visibility and accessibility should also be
% possibly minimized, favoring the use of private over public variables whenever it
% is possible.
%
% Also the names of variables should be taken short for local variables, with
% short scope, leaving to their class names to explicit their behavior.
% Minimizing variability using final and @NonNull annotation. Stress the use of
% generic names technique. Minimize lifespan avoiding persistent variables when
% it is possible. Favor the use of collection instead of arrays. Interfaces
% should present a minimal number of parameters, also minimizing the interaction
% between them. Favor ternarization over the use of if-then-else constructs and
% use a simplified version of the conditionals that implies an early return.
% Moreover, use an early exit logic with continue, break and return instructions.
%
% Everything should be formatted in order to make an efficient use of the screen
% space, by removing unnecessary tokens (i.e., redundant parentheses, etc.).
% Methods should be as short as possible.

\end{description}
