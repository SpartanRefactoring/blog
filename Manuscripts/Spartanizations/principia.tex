The spartan programming style tries to achieve terse, clear and modular code,
by \textit{simultaneous} minimization of these measures:
\begin{enumerate}
  \item \textit{code size,} which here means all of number of lines, number of
        characters, \emph{and}, number of language tokens;
  \item \textit{horizontal complexity,} e.g., the number of lines in each
        method;
  \item \textit{vertical complexity,} e.g., the number of parameters to a
        module (method or generic class), \emph{or} the level of nesting of
        control commands, \kk{if}, \kk{while}, \kk{switch}, etc.
  \item \textit{control complexity,} which is the total number of control
        commands in the code.
  \item \textit{variability,} which means minimizing visibility, ability to
        change, lifetime, and scope of variables, just as their number.
        This means the introduction of \kk{final} whenever possible,
        variable inlining, preferring local variables to parameters, parameters
        to fields, and fields to \kk{static} fields, careful use of
        \cc{public}, etc.
  \item \textit{exploitation of scope,} which means the number of distinct
        identifiers (of fields, methods, etc.) used in any module.
  \item \textit{life and size of stacked context,} which is the most intricate of the
        spartan minimization ends. 
        
        To understand what terms stacked context and its life mean, consider
        this code snippet

        \begin{code}[minipage,width=54ex]{java}
ThingTwo ii = new ThingTwo();
ii.wreck(house);
System.out.println(ii);
ThingOne i = new ThingOne(); // Stack context of £\cc{ii}£
System.out.println(i);       // Context of £\cc{ii}£ still stacked
i.wreck(house);              // Stacked still£…£
System.out.println(i);       // Still!
cat.join(i, ii);             // Finally: recalling context of £\cc{ii}£.
  \end{code}
  The last line in this snippet joins the three objects,
  \cc{cat},~\cc{i}, and \cc{ii}. The four preceding lines prepare
  and print object \cc{i}.

  Object~\cc{i} is prepared and printed in the remainder, i.e., the first three
  lines of the snippet.  The fact that it existed is stacked then during the
  preparation of \cc{i}, and restored only at the last line.

  By swapping the order of construction, we obtain code in which the stacked is
  a bit shorter, \cc{i} instead of \cc{ii}, and in a linear read of the
  program, it is stacked for three rather than four lines.
 
\begin{code}[minipage,width=54ex]{java} 
ThingOne i = new ThingOne();
ThingOne i = new ThingOne(); 
System.out.println(i); 
i.enter(house); 
System.out.println(i);        
ThingTwo ii = new ThingTwo(); // Stack context of £\cc{i}£. 
ii.enter(house);              // Context of £\cc{i}£ still stacked.
System.out.println(ii);       // £\cc{i}£ is stacked still.  
cat.join(i, ii);              // Recalling context of £\cc{ii}£.
  \end{code}
\end{enumerate}

To an extent, these minimization ends are reformulation of traditional
belief on software: that software should be organized in short cohesive modules
whose code depends on few globals, and is frugal in its use of control.
Conversely, complaints on code quality, include deep and complex nesting
\kk{if}s and \kk{for}s, endless parameters' lists, piles of global variables
and many methods and classes that should be understood before understanding any
given method, etc.

Also, the end of minimizing life and size of saved contexts captures in it
principles such as early \cc{throw}, \cc{return} and \cc{break} (from loops) on
errors, ordering by increasing length to increase readability, and also the
practice of placing at first the short branch of an \cc{if} conditional, etc.

The main novelty in spartan programming is not in these numerical minimization
ends, but in the \emph{extent}, \emph{manner}, and \emph{automatization} of the
quest for this minimization. Unlike other coding guidelines, spartanization
prescribes a (semi-automatic) uncompromising process by which code can be
spartanized.


\subsection{Manner of application}
The spartanization process is governed by the spartan
\emph{toolbox}, which is a collection of many (currently around sixty)
structural and nominal wrings.  Each \emph{wring} is a refactoring that does
not degrade quality as measured by any of minimization ends: LOC, number of
tokens, nesting level, size of stacked scope, etc., while improving on at least
one of them.

A \emph{structural wring} is a wring that modifies the structure of the code,
such as the conversion of \cc{\kk{if} (f() == \kk{true}) \kk{return true};
\kk{else return false};} to \cc{\kk{return} f();}. Another structural wring is
the one that removes the useless \kk{abstract} and \kk{public} modifiers from
declarations made withing and \kk{interface}. 

In contrast, a \emph{nominal wring} is a wring that does does not modify the
code itself, but renames some entities in it, most particularly, variables.
For example, the toolbox includes a nominal wring to convert the name of the
variable returned by a method, to the one character identifier ``\cc{\$}'',
which is the short spartan name for result.

If none of the wrings in the toolbox is applicable to the code, then
spartanization has reached a (local) optimum. Otherwise, code spartanization
proceeds by selecting one such wring and continuing with the code obtained
after applying this wring.

This process can be automated or carried out interactively. Many of the wrings
are implemented as part of an open source spartan refactoring Eclipse
plugin\urlref{https://github.com/SpartanRefactoring/spartan-refactoring} which
makes it possible for programmers to apply much of it.

In addition to wrings, spartanization may use 
\begin{itemize}
    \item  clean by external tools, specifically, Eclipse's cleanup operation, 
      to tasks such as minimizing variability as planting \kk{final} modifier
      whenever possible, removing unused variables and methods, etc.  
    \item user intervention for appropriate 
        clever method extraction which would minimize exploitation of scope.
\end{itemize}
Naturally, size increases with the addition of \cc{final}s; other cleanups, such
as the automatic addition of \cc{@Override} annotation may increase size as well.
Also, typically method extraction increases code size, be it measured in lines,
  tokens, characters or bytes. 

Thus, there are four components to the spartanization process:
\emph{\textbf{(i)}} structural, 
\emph{\textbf{(ii)}} nominal, 
\emph{\textbf{(iii)}} cleanup, and,  
\emph{\textbf{(iv)}} method extraction. 
Current technology can automate all but the last component; 
automation of method extraction requires more research,
paying attention to current state of the art \matteo\cite{ 
    we should have many citations
    somewhere can you please add some citations
}.
The empirical \cref{section:initial} below investigates how structural and
nominal spartanizations contribute to the naturalness of code.

\subsection{Extent of application}
An underlying principle is not only that the minimization of
the above ends matters, but also that \emph{nothing else matters}.
In other words, wrings are applied repeatedly, with explicit disregard
to any other extent†{%
  In Spartan words: ‟\textit{As far as this can reach}.” K. Agesilaus the
  great (\textsl{being asked for the extent of Sparta's border, while
  holding his spear}).
}.

Heavily spartanized code is often quite different than the original.  A case in
point is the \Java program presented in \cref{figure:eclipse}, drawn from the
Eclipse JDT Tutorial series\urlref{%
http://www.programcreek.com/2011/01/a-complete-standalone-example-of-astparser/},
but slightly amended for brevity.

\begin{figure}[H]
  \caption{A complete standalone example of using class \cc{ASTParser}, drawn
    from the Eclipse JDT Tutorial Series, abbreviated and reformatted.} 
    \label{figure:eclipse}
    \begin{adjustbox}{max width=\columnwidth}
      \begin{code}[minipage, width=1.13\columnwidth]{JAVA}
public class Test { // comments and £\kk{import}£ directives omitted for brevity
  public static void main(String args[]) {
    ASTParser parser = ASTParser.newParser(AST.JLS3);
    parser.setSource(
      "public class A {\n" + 
      "  int i = 9;\n"+ //
      "  int j;\n" + //
      "  ArrayList<Integer> al = new ArrayList<Integer>();\n" + //
      "  j=1000;\n" + // sic!
      "}\n" + //
      .toCharArray()
    );
    parser.setKind(ASTParser.K£\_£COMPILATION£\_£UNIT);
    CompilationUnit cu = (CompilationUnit) parser.createAST(null);
    cu.accept(new ASTVisitor() {
      Set names = new HashSet();
      public boolean visit(VariableDeclarationFragment node) {
        SimpleName name = node.getName();
        this.names.add(name.getIdentifier());
        System.out.println(
          "Declaration of '" + name + "' at line" + //
          cu.getLineNumber(name.getStartPosition()));
        return false; 
      }
      public boolean visit(SimpleName node) {
        if (this.names.contains(node.getIdentifier())) {
          System.out.println(
            "Usage of '" + node + "' at line " +//
            cu.getLineNumber(node.getStartPosition()));
        }
        return true;
      }
    });
  }
}
\end{code}
  \end{adjustbox}
\end{figure}

\Cref{figure:eclipse:spartan}.
shows a spartanized version of program in the \cref{figure:eclipse}, 

\begin{figure}
  \caption{Spartanized version, including renaming, restructuring, and method extraction 
  of the full \Java program in \cref{figure:eclipse}.}
  \label{figure:eclipse:spartan}
  \def\ignore#1{}
  \begin{adjustbox}{max width = \columnwidth}
\begin{code}[minipage, width=1.13\columnwidth]{JAVA}
public class Test { // comments and £\kk{import}£ directives omitted for brevity
  public static void main(String args[]) { go(); }
  private static void go() {
    CompilationUnit u = makeCompilationUnit();
    u.accept(new ASTVisitor() {
      Set £\ignore$£$ = new HashSet();
      public boolean visit(SimpleName ¢) {
        note(¢);
        return true;
      }
      public boolean visit(VariableDeclarationFragment ¢) {
        collect(¢.getName());
        return false; 
      }
      void note(SimpleName ¢) {
        if (£\ignore$£$.contains(¢.getIdentifier()))
          System.out.println("Usage of '" + ¢ + //
            "' at line " + u.getLineNumber(¢.getStartPosition()));
      }
      void collect(SimpleName ¢) {
        £\ignore$£$.add(¢.getIdentifier());
        System.out.println("Declaration of '" + ¢ + //
          "' at line" + u.getLineNumber(¢.getStartPosition()));
      }
    });
  }
  private static CompilationUnit makeCompilationUnit() {
    return (CompilationUnit) makeParser().createAST(null);
  }
  private static ASTParser makeParser() {
    ASTParser £\ignore$£$ = ASTParser.newParser(AST.JLS3);
    £\ignore$£$.setSource(
      "public class A {\n" + 
      "  int i = 9;\n"+ //
      "  int j;\n" + //
      "  ArrayList<Integer> al = new ArrayList<Integer>();\n" + //
      "  j=1000;\n" + // sic!
      "}\n" + //
      .toCharArray()
    );
    £\ignore$£$.setKind(ASTParser.K£\_£COMPILATION£\_£UNIT);
    return £\ignore$£$;
  }
\end{code}
  \end{adjustbox}
\end{figure}


\subsection{Automatization}
% However, being in a certain sense, counter intuitive, in order to apply
% Spartanization on their working routines, the developers need to respect a firm
% discipline. From a certain standpoint, Spartan Programming might be seen as a
% list of code style prescription, but it would just scratch the surface. It is
% far more than that, since it
% 
% Being minimized, spartanized code might be less readable that the original.
% This is … Spartan programming is not directly concerned with readability, at
% least not in its subjective and cultural-dependent sense. In fact, spartan
% programs will bring much misery to anyone preferring long, verbose programs.
% 
% Spartan programming prescribes, a careful use of the variables, stressing the need
% to inline variables that are used only once and emphasizing the use of foreach loops
% in languages implementing it. Variables visibility and accessibility should also be
% possibly minimized, favoring the use of private over public variables whenever it
% is possible.
% 
% Also the names of variables should be taken short for local variables, with
% short scope, leaving to their class names to explicit their behavior.
% Minimizing variability using final and @NonNull annotation. Stress the use of
% generic names technique. Minimize lifespan avoiding persistent variables when
% it is possible. Favor the use of collection instead of arrays. Interfaces
% should present a minimal number of parameters, also minimizing the interaction
% between them. Favor ternarization over the use of if-then-else constructs and
% use a simplified version of the conditionals that implies an early return.
% Moreover, use an early exit logic with continue, break and return instructions.
% 
% Everything should be formatted in order to make an efficient use of the screen
% space, by removing unnecessary tokens (i.e., redundant parentheses, etc.).
% Methods should be as short as possible.
