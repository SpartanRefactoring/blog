The spartan programming style tries to achieve terse, clear and modular code,
by \textit{simultaneous} minimization of these measures:
\begin{enumerate}
  \item \textit{code size,} which here means all of number of lines, number of
        characters, \emph{and}, number of language tokens;
  \item \textit{horizontal complexity,} e.g., the number of lines in each
        method;
  \item \textit{vertical complexity,} e.g., the number of parameters to a
        module (method or generic class), \emph{or} the level of nesting of
        control commands, \kk{if}, \kk{while}, \kk{switch}, etc.
  \item \textit{control complexity,} which is the total number of control
        commands in the code.
  \item \textit{variability,} which means minimizing visibility, ability to
        change, lifetime, and scope of variables, just as their number.
        This means the introduction of \kk{final} whenever possible,
        variable inlining, preferring local variables to parameters, parameters
        to fields, and fields to \kk{static} fields, careful use of
        \cc{public}, etc.
  \item \textit{exploitation of scope,} which means the number of distinct
        identifiers (of fields, methods, etc.) used in any module.
  \item \textit{life and size of stacked context,} which is the most intricate of the
        spartan minimization ends. 
        
        To understand what terms stacked context and its life mean, consider
        this code snippet

        \begin{code}[minipage,width=54ex]{java}
ThingTwo ii = new ThingTwo();
ii.wreck(house);
System.out.println(ii);
ThingOne i = new ThingOne(); // Stack context of £\cc{ii}£
System.out.println(i);       // Context of £\cc{ii}£ still stacked
i.wreck(house);              // Stacked still£…£
System.out.println(i);       // Still!
cat.join(i, ii);             // Finally: recalling context of £\cc{ii}£.
  \end{code}
  The last line in this snippet joins the three objects,
  \cc{cat},~\cc{i}, and \cc{ii}. The four preceding lines prepare
  and print object \cc{i}.

  Object~\cc{i} is prepared and printed in the remainder, i.e., the first three
  lines of the snippet.  The fact that it existed is stacked then during the
  preparation of \cc{i}, and restored only at the last line.

  By swapping the order of construction, we obtain code in which the stacked is
  a bit shorter, \cc{i} instead of \cc{ii}, and in a linear read of the
  program, it is stacked for three rather than four lines.
 
\begin{code}[minipage,width=54ex]{java} 
ThingOne i = new ThingOne();
ThingOne i = new ThingOne(); 
System.out.println(i); 
i.enter(house); 
System.out.println(i);        
ThingTwo ii = new ThingTwo(); // Stack context of £\cc{i}£. 
ii.enter(house);              // Context of £\cc{i}£ still stacked.
System.out.println(ii);       // £\cc{i}£ is stacked still.  
cat.join(i, ii);              // Recalling context of £\cc{ii}£.
  \end{code}
\end{enumerate}

To an extent, these minimization ends are reformulation of traditional
belief on software: that software should be organized in short cohesive modules
whose code depends on few globals, and is frugal in its use of control.
Conversely, complaints on code quality, include deep and complex nesting
\kk{if}s and \kk{for}s, endless parameters' lists, piles of global variables
and many methods and classes that should be understood before understanding any
given method, etc.

Also, the end of minimizing and life and size of saved contexts captures in it
principles such as early \cc{throw}, \cc{return} and \cc{break} (from loops) on
errors, ordering by increasing length to increase readability, and also the
practice of placing at first the short branch of an \cc{if} conditional, etc.

The main novelty in spartan programming is not in these numerical minimization
ends, but in the \emph{extent}, \emph{manner}, and \emph{automatization} of the
quest for this minimization:

\subsection{Manner of application}
The spartanization process is governed by the spartan
\emph{toolbox}, which is a collection of many (currently around sixty)
wrings.  Each \emph{wring} is a refactoring that does not degrade quality as
measured by any of minimization ends: LOC, number of tokens, nesting level,
size of stacked scope, etc., while improving on at least one of them.

If none of the wrings in the toolbox is applicable to the code, then
spartanization has reached a (local) optimum. Otherwise, code spartanization
proceeds by selecting one such wring and continuing with the code obtained
after applying this wring.

This process can be automated or carried out interactively. Many of the
wrings are implemented as part of an open source spartan refactoring Eclipse
plugin\urlref{https://github.com/SpartanRefactoring/spartan-refactoring}
which makes it possible for programmers to apply much of it.

\subsection{Extent of application}
An underlying principle is not only that the minimization of
the above ends matters, but also that \emph{nothing else matters}.
In other words, wrings are applied repeatedly, with explicit disregard
to any other extent†{%
  In Spartan words: ‟\textit{As far as this can reach}.” K. Agesilaus the
  great (\textsl{being asked for the extent of Sparta's border, while
  holding his spear}).
}.
The resulting spartanized code might be very different than original.
A case in point is the code presented in \cref{figure:eclipse}, drawn from the
Eclipse JDT Tutorial series\urlref{%
http://www.programcreek.com/2011/01/a-complete-standalone-example-of-astparser/},
but slightly amended for brevity.

\begin{figure}[H]
  \caption{A complete standalone example of using class \cc{ASTParser}, drawn
    from the Eclipse JDT Tutorial Series, abbreviated and reformatted.} 
    \label{figure:eclipse}
    \begin{code}[listing style={numbered, language=Java},minipage,width=0.98\columnwidth]{JAVA}
// comments and £\kk{import}£ directives omitted for brevity
public class Test {
  public static void main(String args[]) {
    ASTParser parser = ASTParser.newParser(AST.JLS3);
    parser.setSource(
      "public class A {\n" + 
      "  int i = 9;\n"+ //
      "  int j;\n" + //
      "  ArrayList<Integer> al = new ArrayList<Integer>();\n" + //
      "  j=1000;\n" + // sic!
      "}\n" + //
      .toCharArray()
    );
    parser.setKind(ASTParser.K£\_£COMPILATION£\_£UNIT);
    final CompilationUnit cu = (CompilationUnit) parser.createAST(null);
    cu.accept(new ASTVisitor() {
      Set names = new HashSet();
      public boolean visit(VariableDeclarationFragment node) {
        SimpleName name = node.getName();
        this.names.add(name.getIdentifier());
        System.out.println(
          "Declaration of '" + name + "' at line" + //
          cu.getLineNumber(name.getStartPosition()));
        return false; 
      }
      public boolean visit(SimpleName node) {
        if (this.names.contains(node.getIdentifier())) {
          System.out.println(
            "Usage of '" + node + "' at line " +//
            cu.getLineNumber(node.getStartPosition()));
        }
        return true;
      }
    });
  }
}
  \end{code}
\end{figure}


\begin{figure}[H]
  \caption{Spartanized version of the program in \cref{figure:eclipse}}
  \label{figure:eclipse:spartan}
  \def\ignore#1{}
\begin{code}[listing style={numbered, language=Java},minipage,width=0.98\columnwidth]{JAVA}
import java.util.*;
import org.eclipse.jdt.core.dom.*;

public class Test {
  public static void main(final String args[]) {
    go();
  }
  private static void go() {
    final ASTParser p = makeParser();
    final CompilationUnit u = (CompilationUnit) p.createAST(null);
    u.accept(new ASTVisitor() {
      final Set<String> £\ignore$£$ = new HashSet<>();
      @Override public boolean visit(final SimpleName ¢) {
        note(¢);
        return true;
      }
      @Override public boolean visit(final VariableDeclarationFragment ¢) {
        collect(¢.getName());
        return false; // do not continue to avoid usage info
      }
      void note(final SimpleName ¢) {
        if (£\ignore$£$.contains(¢.getIdentifier()))
          System.out.println("Usage of '" + ¢ + "' at line " + u.getLineNumber(¢.getStartPosition()));
      }
      void collect(final SimpleName ¢) {
        £\ignore$£$.add(¢.getIdentifier());
        System.out.println("Declaration of '" + ¢ + "' at line" + u.getLineNumber(¢.getStartPosition()));
      }
    });
  }
  private static ASTParser makeParser() {
    final ASTParser £\ignore$£$ = ASTParser.newParser(AST.JLS3);
    £\ignore$£$.setSource(
      "public class A {\n" + 
      "  int i = 9;\n"+ //
      "  int j;\n" + //
      "  ArrayList<Integer> al = new ArrayList<Integer>();\n" + //
      "  j=1000;\n" + // sic!
      "}\n" + //
      .toCharArray()
    );
    £\ignore$£$.setKind(ASTParser.K£\_£COMPILATION£\_£UNIT);
    return £\ignore$£$;
  }
}
public class Test {
  public static void main(String args[]) {
    ASTParser parser = ASTParser.newParser(AST.JLS3);
    parser.setSource(
      "public class A { int i = 9;  \n int j;\n" + //
      "ArrayList<Integer> al = new ArrayList<Integer>();j=1000; }" + //
      ""
      .toCharArray()
    );
    parser.setKind(ASTParser.K£\_£COMPILATION£\_£UNIT);
    final CompilationUnit cu = (CompilationUnit) parser.createAST(null);
    cu.accept(new ASTVisitor() {
      Set names = new HashSet();
      public boolean visit(VariableDeclarationFragment node) {
        SimpleName name = node.getName();
        this.names.add(name.getIdentifier());
        System.out.println(
          "Declaration of '" + name + "' at line" + //
          cu.getLineNumber(name.getStartPosition()));
        return false; 
      }
      public boolean visit(SimpleName node) {
        if (this.names.contains(node.getIdentifier())) {
          System.out.println(
            "Usage of '" + node + "' at line " +//
            cu.getLineNumber(node.getStartPosition()));
        }
        return true;
      }
    });
  }
}
  \end{code}
\end{figure}
  41  120 1407 original.java

\subsection{Automatization}
% However, being in a certain sense, counter intuitive, in order to apply
% Spartanization on their working routines, the developers need to respect a firm
% discipline. From a certain standpoint, Spartan Programming might be seen as a
% list of code style prescription, but it would just scratch the surface. It is
% far more than that, since it
% 
% Being minimized, spartanized code might be less readable that the original.
% This is … Spartan programming is not directly concerned with readability, at
% least not in its subjective and cultural-dependent sense. In fact, spartan
% programs will bring much misery to anyone preferring long, verbose programs.
% 
% Spartan programming prescribes, a careful use of the variables, stressing the need
% to inline variables that are used only once and emphasizing the use of foreach loops
% in languages implementing it. Variables visibility and accessibility should also be
% possibly minimized, favoring the use of private over public variables whenever it
% is possible.
% 
% Also the names of variables should be taken short for local variables, with
% short scope, leaving to their class names to explicit their behavior.
% Minimizing variability using final and @NonNull annotation. Stress the use of
% generic names technique. Minimize lifespan avoiding persistent variables when
% it is possible. Favor the use of collection instead of arrays. Interfaces
% should present a minimal number of parameters, also minimizing the interaction
% between them. Favor ternarization over the use of if-then-else constructs and
% use a simplified version of the conditionals that implies an early return.
% Moreover, use an early exit logic with continue, break and return instructions.
% 
% Everything should be formatted in order to make an efficient use of the screen
% space, by removing unnecessary tokens (i.e., redundant parentheses, etc.).
% Methods should be as short as possible.
