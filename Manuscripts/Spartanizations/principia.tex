The spartan programming style tries to achieve terse, clear and modular code,
by \textit{simultaneous} minimization of these measures:
\begin{enumerate}
  \item \textit{code size,} which here means all of number of lines, number of
        characters, \emph{and}, number of language tokens;
  \item \textit{vertical complexity,} e.g., the number of lines in each
        method;
  \item \textit{horizontal complexity,} including, the number of parameters to a
        module (method or generic class), \emph{and} the level of nesting of
        control commands, \kk{if}, \kk{while}, \kk{switch}, etc. However,
        horizontal complexity does not concern line length, which is generally
        discarded by spartanization.
  \item \textit{control complexity,} which is the total number of control
        commands in the code.
  \item \textit{variability,} which means minimizing visibility, ability to
        change, lifetime, and scope of variables, just as their number.
        This means the introduction of \kk{final} whenever possible,
        variable inlining, preferring local variables to parameters, parameters
        to fields, and fields to \kk{static} fields, careful use of
        \cc{public}, etc.
  \item \textit{exploitation of scope,} which means the number of distinct
        identifiers (of fields, methods, etc.) used in any module.
  \item \textit{life and size of stacked context,} which is the most intricate of the
        spartan minimization ends.

        To understand what terms stacked context and its life mean, consider
        this code snippet

\begin{code}[minipage,width=54ex]{java}
ThingTwo ii = new ThingTwo();
ii.wreck(house);
System.out.println(ii);
ThingOne i = new ThingOne(); // Stack context of £\cc{ii}£
System.out.println(i); // Context of £\cc{ii}£ still stacked
i.wreck(house); // Stacked still£…£
System.out.println(i); // Still!
cat.join(i, ii); // Finally: recalling context of £\cc{ii}£.
  \end{code}
  The last line in this snippet joins the three objects,
  \cc{cat},~\cc{i}, and \cc{ii}. The four preceding lines prepare
  and print object~\cc{i}.

  Object~\cc{i} is prepared and printed in the remainder, i.e., the first three
  lines of the snippet. The fact that it existed is stacked then during the
  preparation of~\cc{i}, and restored only at the last line.

  By swapping the order of construction, we obtain code in which the stacked is
  a bit shorter,~\cc{i} instead of~\cc{ii}, and in a linear read of the
  program, it is stacked for three lines rather than four.

\begin{code}[minipage,width=54ex]{java}
ThingOne i = new ThingOne();
System.out.println(i);
i.enter(house);
System.out.println(i);
ThingTwo ii = new ThingTwo(); // Stack context of £\cc{i}£.
ii.enter(house); // Context of £\cc{i}£ still stacked.
System.out.println(ii); // Context is stacked still.
cat.join(i, ii); // Recalling context of £\cc{ii}£.
  \end{code}
\end{enumerate}

\subsection{Rationale}
\label{section:rationale}
To an extent, these minimization ends are reformulation of traditional belief
on software: that software should be organized in short cohesive modules whose
code depends on few globals, and is frugal in its use of control. Conversely,
complaints on code quality, include deep and complex nesting \kk{if}s and
\kk{for}s, endless parameters' lists, piles of global variables and many
methods and classes that should be understood before understanding any given
method, etc.

Also, the end of minimizing life and size of saved contexts captures in it
principles such as early \cc{throw}, \cc{return} and \cc{break} (from loops) on
errors, ordering by increasing length to increase readability, and also the
practice of placing at first the short branch of an \cc{if} conditional, etc.

Unlike other coding guidelines, spartanization prescribes a (semi-automatic)
uncompromising process by which code can be spartanized. The central novelty
therefore in spartan programming is not in these numerical minimization ends,
but in the \emph{manner}, \emph{extent}, and \emph{automation} of the quest
for their optimization. The last three \emph{emphasized} words make the titles
of \cref{section:manner}, \cref{section:extent}, and \cref{section:automation}
ahead.

\subsection{Manner of application}
\label{section:manner}
The spartanization process is governed by the spartan
\emph{toolbox}, which is a collection of many (currently around sixty)
structural and nominal wrings. Each \emph{wring} is a refactoring that does
not degrade quality as measured by any of minimization ends: LOC, number of
tokens, nesting level, size of stacked scope, etc., while improving on at least
one of them.

A \emph{structural wring} is a wring that modifies the structure of the code,
A simple structural wring is the one removing
useless \kk{abstract} and \kk{public} modifiers from
declarations made withing an \kk{interface}.
The application of a chain of structural wrings converts
\begin{lcode}{JAVA}
if (f() == true) {££
  return false;;
} else {££
  return true;;
}
\end{lcode}
\noindent into
\begin{lcode}{JAVA}
return !f();
\end{lcode}
\noindent
This chain includes a wring to remove redundant curly brackets and one for the
removal of redundant semicolons.
Also involved is a wring for the conversion of an \kk{if} into to a
\emph{ternary} expression (one employing the operator~\cc{$·$?$·$:$·$}), and a
wring simplification of ternary expressions involving boolean literals.

In contrast, a \emph{nominal wring} is a wring that does not modify the
code itself, but renames some entities in it, most particularly, variables.
For example, the toolbox includes a nominal wring to convert the name of the
variable returned by a method, to the one character identifier ‟\cc{\$}”,
which is the short spartan name for result.

If none of the wrings in the toolbox is applicable to the code, then
spartanization has reached a (local) optimum. Otherwise, code spartanization
proceeds by selecting one such wring and continuing with the code obtained
after applying this wring.

This process can be automated or carried out interactively. Many of the wrings
are implemented as part of an open source spartan refactoring Eclipse
plugin\urlref{https://github.com/SpartanRefactoring/spartan-refactoring} which
makes it possible for programmers to apply much of it.

In addition to wrings, spartanization may use
\begin{itemize}
    \item cleanup by external tools, specifically, Eclipse's cleanup operation,
      to tasks such as minimizing variability as planting \kk{final} modifier
      whenever possible, removing unused variables and methods, removing
      unnecessary parenthesis, etc.
    \item user intervention for appropriate
        clever method extraction, and other modular restructuring to
        minimize e.g., exploitation of scope.
\end{itemize}
Naturally, size increases with the addition of \cc{final}s; other cleanups, such
as the automatic addition of \cc{@Override} annotation may increase size as well.
Also, typically method extraction and other modular transformations increases
code size, be it measured in lines, tokens, characters or bytes.

Thus, there are four components to the spartanization process:
\emph{\textbf{(i)}} structural,
\emph{\textbf{(ii)}} nominal,
\emph{\textbf{(iii)}} cleanup, and,
\emph{\textbf{(iv)}} modular.
Current technology can automate all but the last component;
automation of method extraction requires more research,
paying attention to current state of the art \matteo~\cite{%%
    we should have many citations
    somewhere can you please add some citations
}.
This section is concerned with the full process of spartanization.
The empirical \cref{section:initial} below investigates how structural and
nominal spartanizations contribute to the naturalness of code.

\subsection{Extent of application}
\label{section:extent}
An underlying principle is not only that the minimization of
the above ends matters, but also that \emph{nothing else matters}.
In other words, wrings are applied repeatedly, with explicit disregard
to any other extent†{%
  In the Spartan's words: ‟\textit{As far as this can reach}.” K. Agesilaus the
  great (\textsl{being asked for the extent of Sparta's border, while
  holding his spear}).
}.

Heavily spartanized code is often quite different than the original. A case in
point can be found in generic class \cc{C0}, defined by the programmer to
include only instance field \cc{inner} of the generic type parameter.

\begin{figure}[H]
  \caption{A generic class representing a cell, along with its Eclipse
  automatically generated methods (28 lines, 94 words, and 649 characters).}
    \label{figure:cell0}
    \begin{adjustbox}{max width=\columnwidth}
% VIM: /begin/+,/end/-!wc
\begin{code}[minipage, width=1.25\columnwidth]{JAVA}
public class C0<T> {
  private T inner;
  public C0(T inner) {
    super();
    this.inner = inner;
  }
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((inner == null) ? 0 : inner.hashCode());
    return result;
  }
  public boolean equals(Object obj) {
    if (this == obj)
      return true;
    if (obj == null)
      return false;
    if (getClass() != obj.getClass())
      return false;
    C0 other = (C0) obj;
    if (inner == null) {
      if (other.inner != null)
        return false;
    } else if (!inner.equals(other.inner))
      return false;
    return true;
  }
}
\end{code}
\end{adjustbox}
\end{figure}

\Cref{figure:cell0} portrays this class along with function members
automatically generated by Eclipse: a constructor and the trivial methods
\cc{equals($·$)} and \cc{hashCode()} methods.

Compare this figure to its spartanized terse version in \cref{figure:cell1}.

\begin{figure}[H]
  \caption{A spartanized version of the \Java class in \cref{figure:cell0}
    automatically generated methods (16 lines, 70 words and 424 characters).}
    \label{figure:cell1}
    \begin{adjustbox}{max width=\columnwidth}
% VIM: /begin/+,/end/-!wc
\begin{code}[minipage, width=1.25\columnwidth]{JAVA}
public class C1<T> {
  private final T inner;
  public C1(T inner) {
    this.inner = inner;
  }
  public int hashCode() {
    return 31 + ((inner == null) ? 0 : inner.hashCode());
  }
  public boolean equals(Object ¢) {
    return ¢ == this || //
      ¢ != null && getClass() == ¢.getClass() && equals((C1) ¢);
  }
  private boolean equals(C1 ¢) {
    return inner == null ? ¢.inner == null : inner.equals(¢.inner);
  }
}
\end{code}
\end{adjustbox}
\end{figure}

Evidently, spartanization has removed all conditionals, replacing these with
the ternary operator and the short-circuit operators, ‟\cc{\textbar\textbar}”
and ‟\cc{＆＆}”. Spartanization also abbreviated \cc{obj} to~\cc{o} and then
renamed it to~\cc{¢}, eliminated the spurious \cc{\kk{super}()} call in the
constructor, as well as the two variables use in \cc{hashCode()}, turning the
function into a single expression.

The resulting code is evidently shorter, and not as nested. Arguably, the code
is also easier explain and understand: For example, function \cc{equals(Object
¢)} in the figure is described by its own code, while relying on the
understanding of the Boolean operators

\begin{quote}\itshape\scriptsize
  If the sent parameter is the same as \cc{this}, then equality is guaranteed.
  Otherwise, the parameter must not be \kk{null}, and must be of the same class
  of \kk{this}. Further, the parameter must also be of the same as class as
  \kk{this}, and equal to \kk{this} also as an instance of this class.
\end{quote}

Notice though that line length, which is not optimized by the wrings, suffered
a bit. We do have fewer lines, but the average number of characters in them
increased from 23 characters to 26.5. Also, the maximal line length increased
from 71 characters to 81. This last increase is due though due to the
extraction of a \kk{private} version of \cc{equals($·$)}, which is carried
out manually, at user's discretion.

\subsection{Automation}
\label{section:automation}
Consider the \Java program presented in \cref{figure:eclipse}, drawn from the
Eclipse JDT Tutorial series\urlref{%
http://www.programcreek.com/2011/01/a-complete-standalone-example-of-astparser},
but slightly amended for brevity.

\begin{figure}[H]
  \caption{\label{figure:eclipse}%
    A complete standalone example of using class \cc{ASTParser}, drawn
    from the Eclipse JDT Tutorial Series, abbreviated and reformatted.}
    \begin{adjustbox}{max width=\columnwidth}
      \begin{code}[minipage, width=1.13\columnwidth]{JAVA}
public class Test0 { // comments and £\kk{import}£ directives omitted for brevity
  public static void main(String args[]) {££
    ASTParser parser = ASTParser.newParser(AST.JLS3);
    parser.setSource((
      "public class A {\n" +
      " int i = 9;\n"+ //
      " int j;\n" + //
      " ArrayList<Integer> al = new ArrayList<Integer>();\n" + //
      " j=1000;\n" + // sic (syntax error in the original)
      "}\n").toCharArray());
    parser.setKind(ASTParser.K£\_£COMPILATION£\_£UNIT);
    CompilationUnit cu = (CompilationUnit) parser.createAST(null);
    cu.accept(new ASTVisitor() {££
      Set names = new HashSet();
      public boolean visit(VariableDeclarationFragment node) {££
        SimpleName name = node.getName();
        this.names.add(name.getIdentifier());
        System.out.println(
          "Declaration of '" + name + "' at line" + //
          cu.getLineNumber(name.getStartPosition()));
        return false;
      }
      public boolean visit(SimpleName node) {££
        if (this.names.contains(node.getIdentifier())) {££
          System.out.println(
            "Usage of '" + node + "' at line " +//
            cu.getLineNumber(node.getStartPosition()));
        }
        return true;
      }
    });
  }
}
\end{code}
  \end{adjustbox}
\end{figure}

\Cref{figure:eclipse:automatic} shows the automatically spartanized version of
the this code.

\begin{figure}
  \caption{\label{figure:eclipse:automatic}%
    An automatically spartanized version of
      the \Java program of \cref{figure:eclipse}.
    }
  \begin{adjustbox}{max width=\columnwidth}
\begin{code}[minipage, width=1.22\columnwidth]{JAVA}
public class Test1 { // comments and £\kk{import}£ directives omitted for brevity
  public static void main(final String[] £\_\_£) {££
    final ASTParser p = ASTParser.newParser(AST.JLS3);
    p.setSource((
      "public class A {\n" +
      " int i = 9;\n"+ //
      " int j;\n" + //
      " ArrayList<Integer> al = new ArrayList<Integer>();\n" + //
      " j=1000;\n" + // sic (syntax error in the original)
      "}\n").toCharArray());
    final CompilationUnit u = (CompilationUnit) p.createAST(null);
    u.accept(new ASTVisitor() {££
      Set £\ignore$£$ = new HashSet();
      @Override public boolean visit(final SimpleName ¢) {££
        if (£\ignore$£$.contains(¢.getIdentifier()))
          System.out.println("Usage of '" + ¢ + //
            "' at line " + u.getLineNumber(¢.getStartPosition()));
        return true;
      }
      @Override public boolean visit(final VariableDeclarationFragment f) {££
        final SimpleName ¢ = f.getName();
        £\ignore$£$.add(¢.getIdentifier());
        System.out.println("Declaration of '" + ¢ + //
          "' at line" + u.getLineNumber(¢.getStartPosition()));
        return false; // do not continue to avoid usage info
      }
    });
  }
}
\end{code}
  \end{adjustbox}
\end{figure}
Each of the several wrings applied to obtain \cref{figure:eclipse:automatic}
  reduced at least one of our minimization ends.
At several occasions, cleanup increased these.
Overall, the result of automatic application of spartanization
  is a reduction in the number of lines, words, and characters
  by factors of~$1.28$,~$1.05$, and~$1.24$, respectively.†{Part of this improvement
    is due to cleanup operation that optimizes the use of \kk{import}; our empirical
  study ignores \kk{import}s.}
Evidently spartanization shrinks even pedestrian code such as that of
\cref{figure:eclipse}.

Follow the example to appreciate the automatic spartanization process involved:

\begin{enumerate}
  \item \emph{Cleanup}, adding \kk{final}s and \cc{@Override} annotations,
      and simplifying the convoluted reference to data member \cc{names}.
    \item \emph{Structural spartanization}, whose operation was limited to the
      removal of one pair of redundant curly brackets.
    \item \emph{Nominal spartanization}, including these operations:
      \begin{description}
        \item[N1] Renaming of the unused
      parameter \cc{args} to \cc{main($·$)} to the spartan name
      \cc{\_\_}, which means ‟unused” in reminiscence of \Prolog's~‟\cc\_”
      name of unused variables.
    \item[N2] Renaming certain variables to~\cc{¢}. The
      spartan name~\cc{¢} is for the most imminent argument or manipulated
      entity that is not \cc{this}, and reminiscent of \kk{it} of \ML and
        \matteo HyperCard~\cite{there:must:be:some:citation:in:our:huge:bib:repository}:
        the variable which is so prevalent in the current piece of code that
        naming it would be waste of words. Stated differently, the
        meaning of a variable named~\cc{¢} should be so clear to the reader that
        reader, that naming it would be a waste of words.

      \item[N3] Renaming variable \cc{parser} to~\cc{p}, and variable~\cc{cu}
        to~\cc{u}. In accordance with the \emph{Linux kernel coding style}%
        \urlref{https://www.kernel.org/doc/Documentation/CodingStyle}
        and other style guides nominal spartanization abbreviates short scoped
        variables: locals and parameters to one letter that uniquely identifies
        their type. For example, type \kk{int} is denoted by~\cc{i} and the
        name of short scoped, variable \cc{int index;} is abbreviated to~\cc{i}.

        More generally, the single letter denoting a long type name is defined
        as the first letter in the last word of the component of the type name.
        Variable \cc{parser} of type \cc{ASTParser} is hence renamed~\cc{p},
        and~\cc{u} is new name of variable \cc{cu} of type \cc{CompilationUnit}.

        Abbreviation is limited to only those cases in which one letter
        uniquely identifies the variables and there are not more than four of
        these. Experience shows that only a small minority of the methods is
        excluded by this limitation.

\end{description}
  \end{enumerate}

\Cref{figure:primality}, drawn from a spartan implementation of
utility services\urlref{%
  https://github.com/SpartanRefactoring/spartan/blob/master/src/il/org/spartan/misc/Primes.java},
  further demonstrates \textbf{N3}. In the inner loop of the test for
  primality, there is no need to spend words and mental effort to name the
  candidate divisor. It is sufficient to refer to it is by the spartan name
~\cc{¢}, and no confusion should arise.

\begin{figure}
\caption{\label{figure:primality}
  Spartan functions to test for primality†{https://github.com/SpartanRefactoring/spartan}
 }
\begin{Code}{JAVA}{il.org.spartan.misc.Primes＃isPrime}
/** Tests for primality.
  * @param ¢ candidate to be tested
  * @return <code><b>true</b></code> <i>iff</i> the parameter is prime. */
public static boolean isPrime(final int ¢) {££
  return ¢ < -1 && isPrime(-¢) // deal with negative values
      || ¢ > 1 && isPrime¢(¢); // any integer >= 2
}
private static boolean isPrime¢(final int i) {££
  assert i >= 2;
  for (int ¢ = 2; ¢ * ¢ <= i; ++¢)
    if (i ％ ¢ == 0)
      return false;
  return true;
}
\end{Code}
\end{figure}

Note that the single parameter to function \cc{isPrime($·$)} can
safely named ‟\cc{¢}”, since the scope does not include
any other bindings.

In contrast, the single parameter to auxiliary \kk{private} function
\cc{isPrime¢($·$)} must be named ‟\cc{i}”, since its scope includes yet another
binding, of some name to the loop variable. Confusion does not rise in naming
the loop variable ``\cc{¢}'' since the name \emph{always} refers to the most
recently defined variable, i.e., the one that occurs last in the most inner
lexical scope.

\Cref{figure:free}, drawn from a spartan implementation of
\Prolog\urlref{https://github.com/yossigil/Protolog}, demonstrates one more kind of
nominal spartanization:
\begin{description}
\item[N4] employ the spartan name~‟\cc{\$}” for
  the \emph{single} variable that represents the
  function's result.†{the name ‟\cc{\$}” is borrowed from many DSLs,
    particularly of regular expressions and languages, in which it denotes the
  concept of termination.}

  The automatic wring heuristic for identifying the ‟result variable”
  by running a tournament between legible candidates result variable,
  abstaining in cases of ties and vacuous matches.
\end{description}

\begin{figure}
    \caption{\label{figure:free}%
      Spartan function to test for the existence of free variables in a
      symbolic-expression, such as those of \protect\Prolog.
      }
    }
\begin{Code}{JAVA}{\scriptsize\texttt{il.org.spartan.protolog.Variable＃freeVariables}}
default Set<Variable> freeVariables() {££
    final Set<Variable> £\ignore$£$ = new LinkedHashSet<>();
    if (isVariable())
     £\ignore$£$.add((Variable) this);
    else
      for (final Term ¢ : this)
       £\ignore$£$.addAll(¢.freeVariables());
    return £\ignore$£$;
  }
\end{Code}
\end{figure}

The code can be
further polished and spartanized by method extraction and other refactoring.
For now, we concentrate on the automatic spartanization, which as explained
above, comes in
two main varieties.
