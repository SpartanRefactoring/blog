The spartan programming style tries to achieve terse, clear and modular code,
by \textit{simultaneous} minimization of these measures:
\begin{enumerate}
  \item \textit{code size,} which here means all of number of lines, number of
        characters, \emph{and}, number of language tokens;
  \item \textit{vertical complexity,} e.g., the number of lines in each
        method;
  \item \textit{horizontal complexity,} including, the number of parameters to a
        module (method or generic class), \emph{and} the level of nesting of
        control commands, \kk{if}, \kk{while}, \kk{switch}, etc. However,
        horizontal complexity does not concern line length, which is generally
        discarded by spartanization.
  \item \textit{control complexity,} which is the total number of control
        commands in the code.
  \item \textit{variability,} which means minimizing visibility, ability to
        change, lifetime, and scope of variables, just as their number.
        This means the introduction of \kk{final} whenever possible,
        variable inlining, preferring local variables to parameters, parameters
        to fields, and fields to \kk{static} fields, careful use of
        \cc{public}, etc.
  \item \textit{exploitation of scope,} which means the number of distinct
        identifiers (of fields, methods, etc.) used in any module.
  \item \textit{life and size of stacked context,} which is the most intricate of the
        spartan minimization ends.

        To understand what terms stacked context and its life mean, consider
        this code snippet

        \begin{code}[minipage,width=54ex]{java}
ThingTwo ii = new ThingTwo();
ii.wreck(house);
System.out.println(ii);
ThingOne i = new ThingOne(); // Stack context of £\cc{ii}£
System.out.println(i); // Context of £\cc{ii}£ still stacked
i.wreck(house); // Stacked still£…£
System.out.println(i); // Still!
cat.join(i, ii); // Finally: recalling context of £\cc{ii}£.
  \end{code}
  The last line in this snippet joins the three objects,
  \cc{cat},~\cc{i}, and \cc{ii}. The four preceding lines prepare
  and print object~\cc{i}.

  Object~\cc{i} is prepared and printed in the remainder, i.e., the first three
  lines of the snippet. The fact that it existed is stacked then during the
  preparation of~\cc{i}, and restored only at the last line.

  By swapping the order of construction, we obtain code in which the stacked is
  a bit shorter,~\cc{i} instead of \cc{ii}, and in a linear read of the
  program, it is stacked for three rather than four lines.

\begin{code}[minipage,width=54ex]{java}
ThingOne i = new ThingOne();
ThingOne i = new ThingOne();
System.out.println(i);
i.enter(house);
System.out.println(i);
ThingTwo ii = new ThingTwo(); // Stack context of £\cc{i}£.
ii.enter(house); // Context of £\cc{i}£ still stacked.
System.out.println(ii); // Context is stacked still.
cat.join(i, ii); // Recalling context of £\cc{ii}£.
  \end{code}
\end{enumerate}

To an extent, these minimization ends are reformulation of traditional
belief on software: that software should be organized in short cohesive modules
whose code depends on few globals, and is frugal in its use of control.
Conversely, complaints on code quality, include deep and complex nesting
\kk{if}s and \kk{for}s, endless parameters' lists, piles of global variables
and many methods and classes that should be understood before understanding any
given method, etc.

Also, the end of minimizing life and size of saved contexts captures in it
principles such as early \cc{throw}, \cc{return} and \cc{break} (from loops) on
errors, ordering by increasing length to increase readability, and also the
practice of placing at first the short branch of an \cc{if} conditional, etc.

Unlike other coding guidelines, spartanization prescribes a (semi-automatic)
uncompromising process by which code can be spartanized. The main novelty
therefore in spartan programming is not in these numerical minimization ends,
but in the \emph{manner}, \emph{extent}, and \emph{automatization} of the quest
for their optimization. The last three \emph{emphasized} words make the titles
of \cref{sction:manner,section:extent,section:automation} ahead.

\subsection{Manner of application}
\label{section:manner}
The spartanization process is governed by the spartan
\emph{toolbox}, which is a collection of many (currently around sixty)
structural and nominal wrings. Each \emph{wring} is a refactoring that does
not degrade quality as measured by any of minimization ends: LOC, number of
tokens, nesting level, size of stacked scope, etc., while improving on at least
one of them.

A \emph{structural wring} is a wring that modifies the structure of the code,
A simple structural wring is the one removing
useless \kk{abstract} and \kk{public} modifiers from
declarations made withing an \kk{interface}.
The application of a chain of structural wrings converts
\begin{lcode}{JAVA}
if (f() == true) {££
  return false;;
} else {££
  return true;;
}
\end{lcode}
\noindent into 
\begin{lcode}{JAVA}
return !f();
\end{lcode}
\noindent 
This chain includes a wring to remove redundant curly brackets and one for the
removal of redundant semicolons.
Also involved is a wring for the conversion of an \kk{if} into to a
\emph{ternary} expression (one employing the operator~\cc{$·$?$·$:$·$}), and a
wring simplification of ternary expressions involving boolean literals.

In contrast, a \emph{nominal wring} is a wring that does does not modify the
code itself, but renames some entities in it, most particularly, variables.
For example, the toolbox includes a nominal wring to convert the name of the
variable returned by a method, to the one character identifier ‟\cc{\$}”,
which is the short spartan name for result.

If none of the wrings in the toolbox is applicable to the code, then
spartanization has reached a (local) optimum. Otherwise, code spartanization
proceeds by selecting one such wring and continuing with the code obtained
after applying this wring.

This process can be automated or carried out interactively. Many of the wrings
are implemented as part of an open source spartan refactoring Eclipse
plugin\urlref{https://github.com/SpartanRefactoring/spartan-refactoring} which
makes it possible for programmers to apply much of it.

In addition to wrings, spartanization may use
\begin{itemize}
    \item cleanup by external tools, specifically, Eclipse's cleanup operation,
      to tasks such as minimizing variability as planting \kk{final} modifier
      whenever possible, removing unused variables and methods, removing
      unnecessary parenthesis, etc.
    \item user intervention for appropriate
        clever method extraction, and other modular restructuring to
        minimize e.g., exploitation of scope.
\end{itemize}
Naturally, size increases with the addition of \cc{final}s; other cleanups, such
as the automatic addition of \cc{@Override} annotation may increase size as well.
Also, typically method extraction and other modular transformations increases
code size, be it measured in lines, tokens, characters or bytes.

Thus, there are four components to the spartanization process:
\emph{\textbf{(i)}} structural,
\emph{\textbf{(ii)}} nominal,
\emph{\textbf{(iii)}} cleanup, and,
\emph{\textbf{(iv)}} modular.
Current technology can automate all but the last component;
automation of method extraction requires more research,
paying attention to current state of the art \matteo~\cite{%%
    we should have many citations
    somewhere can you please add some citations
}.
This section is concerned with the full process of spartanization.
The empirical \cref{section:initial} below investigates how structural and
nominal spartanizations contribute to the naturalness of code.

\subsection{Extent of application}
\label{section:extent}
An underlying principle is not only that the minimization of
the above ends matters, but also that \emph{nothing else matters}.
In other words, wrings are applied repeatedly, with explicit disregard
to any other extent†{%
  In the Spartan's words: ‟\textit{As far as this can reach}.” K. Agesilaus the
  great (\textsl{being asked for the extent of Sparta's border, while
  holding his spear}).
}.

Heavily spartanized code is often quite different than the original. A case in
point can be found in generic class \cc{C0}, defined by the programmer to
include only instance field \cc{inner} of the generic type parameter.
\cref{figure:cell0} portrays this class along with function members
automatically generated by Eclipse: a constructor and the trivial methods
\cc{equals($·$)} and \cc{hashCode()} methods.

\begin{figure}
  \caption{A generic class representing a cell, along with its Eclipse
  automatically generated methods (28 lines, 94 words, and 649 characters).}
    \label{figure:cell0}
    \begin{adjustbox}{max width=\columnwidth}
% VIM: /begin/+,/end/-!wc
\begin{code}[minipage, width=1.25\columnwidth]{JAVA}
public class C0<T> {
  private T inner;
  public C0(T inner) {
    super();
    this.inner = inner;
  }
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((inner == null) ? 0 : inner.hashCode());
    return result;
  }
  public boolean equals(Object obj) {
    if (this == obj)
      return true;
    if (obj == null)
      return false;
    if (getClass() != obj.getClass())
      return false;
    C0 other = (C0) obj;
    if (inner == null) {
      if (other.inner != null)
        return false;
    } else if (!inner.equals(other.inner))
      return false;
    return true;
  }
}
\end{code}
\end{adjustbox}
\end{figure}

Compare this figure to its spartanized version, as showing in
\cref{figure:cell1}

\begin{figure}
  \caption{A spartanized version of the \Java class in \cref{figure:cell0}
    automatically generated methods (16 lines, 70 words and 424 characters).}
    \label{figure:cell1}
    \begin{adjustbox}{max width=\columnwidth}
% VIM: /begin/+,/end/-!wc
\begin{code}[minipage, width=1.25\columnwidth]{JAVA}
public class C1<T> {
  private final T inner;
  public C1(T inner) {
    this.inner = inner;
  }
  public int hashCode() {
    return 31 + ((inner == null) ? 0 : inner.hashCode());
  }
  public boolean equals(Object o) {
    return o == this || //
      o != null && getClass() == o.getClass() && equals((C1) o);
  }
  private boolean equals(C1 c) {
    return inner == null ? c.inner == null : inner.equals(c.inner);
  }
}
\end{code}
\end{adjustbox}
\end{figure}
Evidently, spartanization has removed all conditionals, replacing these with
the ternary operator and the short-circuit operators, ‟\cc{\textbar\textbar}”
and ‟\cc{＆＆}”. Spartanization also abbreviated \cc{obj} to \cc{o}.  The code
is evidently shorter, and not as nested.  

Notice however that line length, which is not optimized by the wrings, suffered
a bit.  We do have fewer lines, but the average number of characters in them
increased from 23 characters to 26.5. Also, the maximal line length increased
from 71 characters to 81. This last increase is due though due to the
extraction of a \kk{private} version of \cc{equals($\cdot$)}, which is carried
out manually, and at user's discretion. 

\subsection{Automation}
\label{section:automation}
Consider the \Java program presented in \cref{figure:eclipse}, drawn from the
Eclipse JDT Tutorial series\urlref{%
http://www.programcreek.com/2011/01/a-complete-standalone-example-of-astparser},
but slightly amended for brevity.

\begin{figure}
  \caption{A complete standalone example of using class \cc{ASTParser}, drawn
    from the Eclipse JDT Tutorial Series, abbreviated and reformatted.} \label{figure:eclipse}
    \begin{adjustbox}{max width=\columnwidth}
      \begin{code}[minipage, width=1.13\columnwidth]{JAVA}
public class Test0 { // comments and £\kk{import}£ directives omitted for brevity
  public static void main(String args[]) {££
    ASTParser parser = ASTParser.newParser(AST.JLS3);
    parser.setSource((
      "public class A {\n" +
      " int i = 9;\n"+ //
      " int j;\n" + //
      " ArrayList<Integer> al = new ArrayList<Integer>();\n" + //
      " j=1000;\n" + // sic!
      "}\n").toCharArray());
    parser.setKind(ASTParser.K£\_£COMPILATION£\_£UNIT);
    CompilationUnit cu = (CompilationUnit) parser.createAST(null);
    cu.accept(new ASTVisitor() {££
      Set names = new HashSet();
      public boolean visit(VariableDeclarationFragment node) {££
        SimpleName name = node.getName();
        this.names.add(name.getIdentifier());
        System.out.println(
          "Declaration of '" + name + "' at line" + //
          cu.getLineNumber(name.getStartPosition()));
        return false;
      }
      public boolean visit(SimpleName node) {££
        if (this.names.contains(node.getIdentifier())) {££
          System.out.println(
            "Usage of '" + node + "' at line " +//
            cu.getLineNumber(node.getStartPosition()));
        }
        return true;
      }
    });
  }
}
\end{code}
  \end{adjustbox}
\end{figure}

\Cref{figure:eclipse:automatic} shows the automatically spartanized version of
the this code. Employed were cleanup operations (adding \kk{final}s and
\cc{@Override} annotations, and the convoluted reference to \cc{names}),
structural spartanization (removing redudant curly brackets) and nominal
spartanization, renaming variable \cc{names} to~\cc{\$}, and variables in which
occur in scopes where no ambiguity can occur to~\cc{¢}.

\begin{figure}
  \caption{An automatically spartanized version of
      the \Java program of \cref{figure:eclipse}}
    \label{figure:eclipse:automatic}
    \begin{adjustbox}{max width=\columnwidth}
\begin{code}[minipage, width=1.20\columnwidth]{JAVA}
public class Test1 { // comments and £\kk{import}£ directives omitted for brevity
  public static void main(final String args[]) {££
    final ASTParser p = ASTParser.newParser(AST.JLS3);
    p.setSource((
      "public class A {\n" +
      " int i = 9;\n"+ //
      " int j;\n" + //
      " ArrayList<Integer> al = new ArrayList<Integer>();\n" + //
      " j=1000;\n" + // sic!
      "}\n").toCharArray());
    final CompilationUnit u = (CompilationUnit) p.createAST(null);
    u.accept(new ASTVisitor() {££
      Set £\ignore$£$ = new HashSet();
      @Override public boolean visit(final SimpleName ¢) {££
        if (£\ignore$£$.contains(¢.getIdentifier()))
          System.out.println("Usage of '" + ¢ + //
            "' at line " + u.getLineNumber(¢.getStartPosition()));
        return true;
      }
      @Override public boolean visit(final VariableDeclarationFragment f) {££
        final SimpleName ¢ = f.getName();
        £\ignore$£$.add(¢.getIdentifier());
        System.out.println("Declaration of '" + ¢ + //
          "' at line" + u.getLineNumber(¢.getStartPosition()));
        return false; // do not continue to avoid usage info
      }
    });
  }
}
\end{code}
  \end{adjustbox}
\end{figure}

Each of the several wrings applied to obtain \cref{figure:eclipse:automatic}
  reduced at least one of our minimization ends.
At several occasions, cleanup increased these.
Overall, in this case, the result of automatic application of spartanization
  is a reduction in the number of lines, words, and characters
  by factors of~$1.6$,~$1.18$, and~$1.4$.\footnote{Part of this improvement
  is due to cleanup, optimization the use of \kk{import}; we shall account
  for this phenomena in the empirical section.} 

We can witness the impact of spartanization, even on pedestrian code such as
the one given \cref{figure:eclipse}. The code can be further polished and
spartanized by method extraction and other refactorings. For now, we
concentrate on the automatic spartanization, which as explained above, comes in
two main varieties.

Nominal spartanization, tries, in accordance with the recommendations of the Linux
coding guidelines\urlref{}


