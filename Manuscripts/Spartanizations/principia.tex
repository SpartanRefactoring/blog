The spartan programming style tries to achieve terse, clear and modular code,
by \textit{simultaneous} minimization of metrics such as:
\begin{enumerate}
  \item \textit{code size,} which here means all of number of lines, number of
    characters, \emph{and}, number of language tokens;
  \item \textit{horizontal complexity,}  e.g., the number of lines in each
    method;
  \item \textit{vertical complexity,}  e.g., the number of parameters to a
    module (method or generic class), \emph{or} the level of nesting of control
    commands, \kk{if}, \kk{while}, \kk{switch}, etc.
  \item \textit{control complexity,} which is the total number of control
    commands in the code.
  \item \textit{exploitation of scope,} which means the number of distinct
    identifiers (of fields, methods, etc.) used in any module. 
\end{enumerate}

To an extent, these minimization principles are reformulation of traditional
belief on software: that software should be organized in short cohesive modules
whose code depends on few globals, and is frugal in its use of control.
Conversely, complaints on code quality, include deep and complex nesting
\kk{if}s and \kk{for}s, endless parameters' lists, piles of global variables
and many methods and classes that should be understood before understanding any
given method, etc.

The main novelty in spartan programming is not in these minimization
principles, but in the \emph{extent}, \emph{manner}, and \emph{automatization}
of their application: 

\begin{description}
  \item[Extent]
  \item[Manner]
  \item[Automatization]
\end{description}


However, being in a certain sense, counter intuitive, in order to apply
Spartanization on their working routines, the developers need to respect a firm
discipline. From a certain standpoint, Spartan Programming might be seen as a
list of code style prescription, but it would just scratch the surface. It is
far more than that, since it

Being minimized, spartanized code might be less readable that the original.
This is ... Spartan programming is not directly concerned with readability, at
least not in its subjective and cultural-dependent sense. In fact, spartan
programs will bring much misery to anyone preferring long, verbose programs.

Spartan programming prescribes, a careful use of the variables, stressing the need
to inline variables that are used only once and emphasizing the use of foreach loops
in languages implementing it. Variables visibility and accessibility should also be
possibly minimized, favoring the use of private over public variables whenever it
is possible.

Also the names of variables should be taken short for local variables, with
short scope, leaving to their class names to explicit their behavior.
Minimizing variability using final and @NonNull annotation. Stress the use of
generic names technique. Minimize lifespan avoiding persistent variables when
it is possible. Favor the use of collection instead of arrays. Interfaces
should present a minimal number of parameters, also minimizing the interaction
between them. Favor ternarization over the use of if-then-else constructs and
use a simplified version of the conditionals that implies an early return.
Moreover, use an early exit logic with continue, break and return instructions.

Everything should be formatted in order to make an efficient use of the screen
space, by removing unnecessary tokens (i.e., redundant parentheses, etc.).
Methods should be as short as possible.
