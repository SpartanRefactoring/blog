% \matteo: can you please proof read this section?
% \matteo: uncomment if you are done.

Having described the spartanization style and process, we now turn to the
question of evaluation.  Our hypothesis here is that both structural and
nominal spartanization make the code more regular. The conjecture is that
spartanization should: preserve semantics, reduce code size, and making the
code \emph{more compressible}. The challenge is in meeting the conjunction of
the three conditions in the conjecture:
\begin{itemize}
    \item The removal of all code decreases size, but does not preserve semantics.
    \item Compression by a tool such as GZip, reduces size, preserves
      semantics. However, compression power is certain to suffer. It is 
      not possible to further compress \cc{.zip} files, whereas plain code
      compresses typically in a factor of two or more.
    \item Another operation which preserves semantics while making
      the code smaller is the reducing runs of whitespace characters combined 
      with all spaces that surround non-alphabetical operators. 
      However, since white spaces are used so frequently in the code,
      this action is likely to make the result less compressible than the origin. 
    \item Even the plain removal of curly brackets in singleton blocks as
      recommended by one of the battling camps of the braces war, is not guaranteed
      to improve compressibility. A good predictor is likely to discover that a
      an opening curly bracket always occurs after the conditional of an \kk{if}. 
      It might become less efficient when this character bracket does not always occur. 
\end{itemize}

Of the four components of the process, we are most interested in structural and
nominal spartanization. The other two components are left beyond the scope of
this work.  Cleanup for spartanization is a bit less interesting, since it is
not particular to spartanization.  Upon automation of method extraction, future
research is to evaluate the quality of these. 

As shall be revealed below, there is a strong empirical evidence to support
the conjecture, when limited to structural sparnization. The results regarding
nominal spartanization are inconclusive, and the reduction we witness in 
compressibility is not statistically significant. 

From the perspective of  language software engineering, the main research
question that concerns us here can be phrased as follows:
\begin{description}
  \item[RQ1.] \emph{Is spartan code more natural than non-spartanized code?} also,
        and more concretely,
        \begin{description}
          \item[RQ1.1.] \emph{Does structural spartanization contribute software naturalness?}
          \item[RQ1.2.] \emph{Does renaming spartanization contribute software naturalness?}
        \end{description}
\end{description}
Yet another question that intrigues us here is:
\begin{description}
  \item[RQ2.] Find an approximation of software's
        naturalness~\cite{Hindle:Bar:Su:Gabel:Devanbu:12} suitable
        for experiments with spartan code.
\end{description}

\subsection{Data Corpus}
We used the ‟Gil-Lalouche”~\cite{Gil:Lalouche:16} software corpus,
assembled from~26 popular \Java open source software artifacts collected
from~\emph{GitHub's Trending
  repositories}\urlref{https://github.com/trending?l=java＆since=monthly} and
the \emph{GitHub \Java Corpus}%
\urlref{http://groups.inf.ed.ac.uk/cup/javaGithub/}
list due to Allamanis and Sutton~\cite{Allamanis:Sutton:13}.

The ‟Size Before” column of \Cref{table:corpus} provides the chief size
statistics of the constituting artifacts.

\begin{table}
  \caption{\label{table:corpus}%
    Aggregating statistics, over artifacts in the corpus,
  of compression power of BZip2 and size, before and after compression.}
  \par\vspace{10pt plus 6pt minus 4pt}
  \centering
  \begin{adjustbox}{max width=\columnwidth}
    \scriptsize
    \begin{tabular}{l*3r}
      \toprule
      & \multicolumn{2}{c}{\textit{Size (bytes)}}⏎
      \cmidrule(r){2-3}
      & \textit{Before}
      & \textit{After}
      & \multicolumn1c{\textit{Power}}⏎
      \midrule % VIM: +,/bottom/-!column -t|sed 's/^/ /'
      \sffamily  Ave.  & 12,370,223 & 1,272,331 & 9.25⏎
      \sffamily  Min.  & 1,019,125  & 129,114   & 7.22⏎
      \sffamily  Max.  & 46,965,422 & 5,607,599 & 12.96⏎
      \sffamily  Med.  & 5,128,541  & 607,535   & 8.91⏎
      \sffamily  Range & 45,946,297 & 5,478,485 & 5.74⏎
      \bottomrule
    \end{tabular}
  \end{adjustbox}
\end{table}

Notably, sizes†span more than one
order of magnitude, from one megabyte of source to circa~47, the median being
around five megabytes, the average around twelve. The GL corpus was used before
for the study of software metrics.  See~\cite{Gil:Lalouche:16,Gil:Lalouche:16b}
for reproducibility details and for a description of the artifacts' selection
process. Sufficient to us here is that the selection was independent of the
current research and that the artifacts are of considerable size, wide use,
evolution history and, development effort.

\subsection{Burrows-Wheeler Compression}
Compression power is used in this work-in-progress report as a quick estimate
of software's naturalness~\cite{Hindle:Bar:Su:Gabel:Devanbu:12}. The measures
are similar but not identical: Compression algorithms search (and exploit) the
input for repetitive patterns of unbounded length, while naturalness limits the
search to~$n$-grams for some small integer~$n$. The difficulty with applying
vanilla naturalness measures is that they become prohibitively slow
for~$n>5$~(say). Alas, patterns of spartanizations, just like refactoring,
often manipulate many more than~$5$ tokens.

Quality in compression algorithms is measured by \emph{compression power},
defined as the ratio of uncompressed size to the compressed size. Compression
power, our \emph{approximate naturalness} should be correlated with
\emph{original naturalness}, but it distincts from it.

We found that with respect to \Java software the compression power of BZip2 is
greater than that of GZip. This greater power is probably because Gzip make a
greedy search for repetitions starting at the input's prefix, while BZip2
starts the search in a broader context, as implied by the Burrows-Wheeler
algorithm~\cite{Burrows:Wheeler:94}.

The second and third columns of \cref{table:corpus} provide statistics of
compressed size and compression power of BZip2\urlref{http://bzip.org/}. As in
the study of naturalness of software, we witness the fact that projects can be
very different. There is two fold range variation of their associated
compression power, as there is in their naturalness.

\subsection{The Jack Preprocessor}

Even though software artifacts often includes more than just \cc{.java} files,
size and other data are of these files only. The rationale is that we wish to
concentrate on the naturalness of the \Java code itself, rather auxiliary
material such as configuration information. 
Note that \cc{.java} files often contain more text than just plain code.  To
better focus on the code itself, this study employs \emph{Jack}, a special
purpose \Java preprocessor applied prior to compression.

Jack replaces each keyword and operator with a single one byte token. The
rationale is that keywords such as \kk{class} are read and produced by
programmers as an individual cohesive token, rather than a sequence of letters
that form an identifier, or sequence of digits that make a numeric literal.

Jack also eliminates from the \Java code all of the following five: white space
characters, \kk{package} declaration, \kk{import} directives, comments of all
sorts, and, the body of all string literals. The assumption here is that each
of these is not a product of pure coding effort: White space characters are
generated and frequently change by automatic code formatting. Also, \kk{import}
directives are generated and optimized automatically, and are subject to
underlying project guideline. Comments also follow their own style, which is
very different from that of the code, \emph{and}, string literals, at least
those with significant content, are ought to be managed by configuration and
internationalization processes rather than coding per-se.
Jack currently does not remove unit-tests, but is planned to do so in the
future.

\Cref{table:virgin} presents the compression power of Jack, BZip, when
applied after Jack, and the accumulative compression power of Jack and BZip2
when applied in this order.
\begin{table}
  \caption{\label{table:virgin}%
    Aggregating statistics, over artifacts in the corpus,
    of size and compression power of Jack and Jack combined with BZip2 
    relative to the original software.
  }
  \par\vspace{10pt plus 6pt minus 4pt}
  \centering
  \begin{adjustbox}{max width = \columnwidth}
    \begin{tabular}{l*5r}
      \toprule
      & \multicolumn2c{\textit{Jack}}
      & \multicolumn2c{\textit{BZip2 after Jack}}
      & \multicolumn1c{\textit{Jack+BZip2}}⏎
      \cmidrule(r){2-3} \cmidrule(r){4-5} \cmidrule(r){6-6}
      & \textit{Size (bytes)}
      & \textit{Powr}
      & \textit{Size (bytes)}
      & \textit{Powr}
      & \textit{Power}⏎
      \midrule % VIM: +,/bottom/-!column -t|sed 's/^/ /'
      \sffamily  Ave.  & 5,078,034  & 2.78  & 729,934   & 6.60 & 18.37⏎
      \sffamily  Min.  & 456,050    & 1.73  & 77,706    & 4.89 & 10.18⏎
      \sffamily  Max.  & 19,697,634 & 12.85 & 3,414,889 & 8.68 & 83.65⏎
      \sffamily  Med.  & 1,822,510  & 2.34  & 343,815   & 6.50 & 15.95⏎
      \sffamily  Range & 19,241,584 & 11.12 & 3,337,183 & 3.79 & 73.47⏎
      \bottomrule
    \end{tabular}
  \end{adjustbox}
\end{table}
In the table, we can observe that Jack typically compress files to half their
size, although there are some artifacts (with many \kk{import}s and comments),
in which the removal of boilerplate material from the program make a ten fold
reduction in size.

The combined compression power of Jack and BZip2 reaches greater values,
ranging from circa 10 fold compression to circa 80 fold. However, the more
% With regards to the Jack algorithm for the spartanized code, we can see that the statistics is
% lightly worse that in the original code. 
% It means that Jack is not able to compress spartanized code better than in the case of the original
% code. 
% It something expected since Spartanization removes

% which reports the difference 
% in the aggregatint statistics for the Jacked code and for the It is
% worth to note that we have an improvement in any (???) statistics, in other words the
% spartanization affected positively the compression, increasing the compression
% power. This is counter intuitive, being a small file most difficult to
% compress than a larger one (REFORMULATE)
interesting measure is the ``BZip2 after Jack'' compression power. This measure is
our \emph{approximate naturalness}, which answers \textbf{RQ2}. Approximate
naturalness is telling how much the essence of the code itself, discarding
boilerplate is compressible (and hence predictable, or, approximately natural).

Comparing the penultimate column (``Powr'') of the \cref{table:virgin} 
with the final column (``Power'') of
\cref{table:corpus}, we see that overall, Jack reduces the compression power of
BZip2. All five statistics: average, min, max, median, and range, are higher
when BZip2 is applied to the original code, than if it is applied to the Jacked
code. In other words, approximate naturalness of non-filtered code is better
than that of jacked code. This should not be a surprise: there are good reasons
to assume that compression of comments, strings, and boilerplate \kk{import}s,
is better than that of the code itself. If these are eliminated from the input,
then compression power is expected to decrease.

\subsection{Structural Spartanization and Approximate Naturalness}

In the first set of experiments, designed to answer \textbf{RQ1.1}, \Java code
in the software artifacts were subjected to our automatic spartanization
tool, configured to employ structural wrings. 
The results are reported in \cref{table:structural} where are reported 
the compression power of the Jacked code and its approximate 
naturaleness (Jack+BZip2). 
We compared these results % approximate naturalness of the automatically spartanized code 
with those related to the original code.
We specifically subtract the aggregating statistics of the latter with those related to the former.
\cref{table:difference} reports the outcome of this comparison. 
% of the aggragating statistics for the latter, related to 
% the spartanized code, and the compression power of the original code. 

The first column of \cref{table:difference} regards the application of the Jack algorithm to the spartanized code. 
As we can see some of the results are negative.
For example, the average value of the compression power is negative, meaning that the Spartanized Jacked code 
il less compressed than the original.
However we are not considering a significative difference.
Also the Max value is negative. As a matter of fact the Max value for the Spartanized code is 
significantly different from the corresponding value in the original, being the latter greater.
This might be due to the fact that there could be case that Spartanized code 
tend to be more laconic, with many variables removed, and code inlined. 
When Jack algorithm removes the tokens that are repeated several times in a .java file 
(i.e. modifiers: abstract, public, private; import
instructions; terms like extends, implements, try, catch).
From this point of view, boilerplate code is less repetitive
% meaning that the spartanized jacked code is less compressed 
% than the Jacked original one. 
% This can be explained if we take into account the fact that Spartanization removes some 
% of the elements that are removed also by Jack.

The second column of the same Table regards the approximate naturalness of the 
spartanized jacked code.  All difference are positive, implying the
answer to \textbf{RQ1.1}: approximate naturalness of a structurally spartanized code
is higher than that of the original.

\begin{table}
  \caption{Aggregating statistics of compression power of Jack+BZip2 after
  automatic \textbf{structural} spartanization, compared with non-spartanized code. 
  }
  \label{table:structural}
  \par\vspace{10pt plus 6pt minus 4pt}
  \centering
  \begin{adjustbox}{max width = \columnwidth}
    \begin{tabular}{l*6r}
      \toprule
      & \multicolumn2c{\textit{Jack}}
      & \multicolumn2c{\textit{Jack+BZip2}}
      & \multicolumn2c{\textit{Combined}}\\
      \cmidrule(r){2-3} \cmidrule(r){4-5} \cmidrule(r){6-6}
      & \textit{Size (bytes)}
      & \textit{Powr}
      & \textit{Size (bytes)}
      & \textit{Powr}
      & \textit{Power}⏎
      \midrule % VIM: +,/bottom/-!column -t|sed 's/^/ /'
      \sffamily  Ave.  & 5,050,647  & 2.46 & 719,488   & 6.66 & 0.06  & 1.01 \\
      \sffamily  Min.  & 439,825    & 1.79 & 75,391    & 4.90 & -0.37 & 0.21 \\  
      \sffamily  Max.  & 19,173,224 & 3.87 & 3,275,918 & 8.79 & 0.49  & 1.07 \\
      \sffamily  Med.  & 1,959,917  & 2.41 & 341,851   & 6.79 & 0.86  & 0.87 \\
      \sffamily  Range & 18,733,399 & 2.08 & 3,200,527 & 3.89 & 0.08  & 0.08 \\
      \bottomrule
    \end{tabular}
  \end{adjustbox}
\end{table}

\begin{table}
  \caption{%
  Difference between the aggregating statistics for the compression power of the spartanized and the original code.
  }
  \label{table:difference}
  \par\vspace{10pt plus 6pt minus 4pt}
  \centering
  \begin{adjustbox}{max width = \columnwidth}
    \begin{tabular}{l*3r}
      \toprule
      & \multicolumn1c{\textit{Jack}}
      & \multicolumn1c{\textit{Jack+BZip2}}
      & \multicolumn1c{\textit{Combined}}⏎
%       \cmidrule(r){2-3} \cmidrule(r){4-5} \cmidrule(r){6-6}
%       & \textit{Size (bytes)}
      & \textit{Powr}
%       & \textit{Size (bytes)}
      & \textit{Powr}
      & \textit{Power}⏎
      \midrule % VIM: +,/bottom/-!column -t|sed 's/^/ /'
\sffamily  Ave.  & -0.32 & 0.06  & -1.95  \\
\sffamily  Min.  &  0.06 & 0.01  &  0.40  \\  
\sffamily  Max.  & -8.98 & 0.11  & -55.46 \\
\sffamily  Med.  &  0.07 & 0.29  &  0.62  \\
\sffamily  Range & -9.04 & 0.10  & -55.86 \\
      \bottomrule
    \end{tabular}
  \end{adjustbox}
\end{table}

\begin{table}
  \caption{CHECK ME I think only last two columns make sense: Aggregating
  statistics of compression power of Jack+BZip2 after automatic structural
spartanization, compared with non-spartanized code.}
  \label{table:structural-comparison}
  \par\vspace{10pt plus 6pt minus 4pt}
  \centering
  \begin{adjustbox}{max width=\columnwidth}
    \begin{tabular}{l*6r}
      \toprule
      & \multicolumn2c{\textit{Size (bytes)}}
      & \multicolumn2c{\textit{Powr}}
      & \multicolumn1c{\textit{Improvement}}\\
%       \cmidrule(r){2-3}\cmidrule(r){4-5} \cmidrule(r){6-6}
      & \textit{Jack}
      & \textit{Jack+BZip2}
      & \textit{BZip2 on Jack}
      & \textit{Combined}
      & \textit{with. Spartan}
      & \textit{total with partial}\\
      \midrule % VIM: +,/bottom/-!column -t|sed 's/^/ /'
      \sffamily  Ave.  & 5,050,647  & 719,488   & 6.66 & 15.88 & 16.42 & 1.01 \\
      \sffamily  Min.  & 439,825    & 75,391    & 4.90 & 10.58 & 10.58 & 0.21 \\  
      \sffamily  Max.  & 19,173,224 & 3,275,918 & 8.79 & 23.21 & 28.19 & 1.07 \\
      \sffamily  Med.  & 1,959,917  & 341,851   & 6.79 & 12.63 & 16.57 & 0.87 \\
      \sffamily  Range & 18,733,399 & 3,200,527 & 3.89 & 15.27 & 17.61 & 1.04 \\
      \bottomrule
    \end{tabular}
  \end{adjustbox}
\end{table}

\begin{table}
  \caption{\label{table:structural2}%
    Aggregating statistics of compression power of Jack+BZip2 after
  automatic structural spartanization.}
  \par\vspace{10pt plus 6pt minus 4pt}
  \centering
  \begin{adjustbox}{max width = \columnwidth}
    \begin{tabular}{l*5r}
      \toprule
      & \multicolumn2c{\textit{Jack}}
      & \multicolumn2c{\textit{BZip2 after Jack}}
      & \multicolumn1c{\textit{Jack+BZip2}}⏎
      \cmidrule(r){2-3} \cmidrule(r){4-5} \cmidrule(r){6-6}
      & \textit{Size (bytes)}
      & \textit{Powr}
      & \textit{Size (bytes)}
      & \textit{Powr}
      & \textit{Power}⏎
      \midrule % VIM: +,/bottom/-!column -t|sed 's/^/ /'
      \sffamily  Ave.  & 5,050,647  & 6.66 & 719,488   & 15.88 &  \\
      \sffamily  Min.  & 439,825    & 4.90 & 75,391    & 10.58 &  \\  
      \sffamily  Max.  & 19,173,224 & 8.79 & 3,275,918 & 23.21 &  \\
      \sffamily  Med.  & 1,959,917  & 6.79 & 341,851   & 12.63 &  \\
      \sffamily  Range & 18,733,399 & 3.89 & 3,200,527 & 15.27 &  \\
      \bottomrule
    \end{tabular}
  \end{adjustbox}
\end{table}

\subsection{Renaming Spartanization}
\begin{table}
  \caption{\label{table:total}%
    Aggregating statistics of compression power of Jack+BZip2 after
  automatic structural+renaming spartanization, compared with non-spartanized code.}
  \par\vspace{10pt plus 6pt minus 4pt}
  \centering
  \begin{adjustbox}{max width=\columnwidth}
    \begin{tabular}{l*5r}
      \toprule
      & \multicolumn{2}{c}{\textit{Size (bytes)}}
      & \textit{Power}
      &\multicolumn{2}{c}{\textit{Improvement over}}⏎
      \cmidrule(r){2-3} \cmidrule(r){5-6}
      & \textit{Jack}
      & \textit{Jack+BZip2}
      & & \textit{Overall}
      & \textit{Partial Spartan.}⏎
      \midrule % VIM: +,/bottom/-!column -t|sed 's/^/ /'
      \sffamily  Ave\@. & 4,947,319  & 713,857   & 6.56 & -0.03 & -0.09⏎
      \sffamily  Min\@. & 430,375    & 75,160    & 4.89 & -0.40 & -0.28⏎
      \sffamily  Max\@. & 18,890,899 & 3,244,851 & 8.72 & 0.41  & -0.01⏎
      \sffamily  Med\@. & 1,923,056  & 339,930   & 6.70 & 0.00  & -0.09⏎
      \sffamily  Range  & 18,460,524 & 3,169,691 & 3.83 & 0.81  & 0.27⏎
      \bottomrule
    \end{tabular}
  \end{adjustbox}
\end{table}

% Preliminary results supporting the
% ‟Hypothesis that can never be proved”
% Because this is not what you like.
