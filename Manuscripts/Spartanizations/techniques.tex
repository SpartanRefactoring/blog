Spartanization aims at minimizing:
\begin{itemize}
 \item Vertical complexity: the number of lines of code.
 \item Horizontal complexity.
 \item Characters, tokens, parameters and variable.
 \item Loops.
 \item Conditional statements.
\end{itemize}

<<<<<<< HEAD
% Spartan programming prescribes, a careful use of the variables, stressing the need
% to inline variables that are used only once and emphasizing the use of foreach loops
% in languages implementing it. Variables visibility and accessibility should also be
% possibly minimized, favoring the use of private over public variables whenever it
% is possible.

% Also the names of variables should be taken short for local variables, with short scope, leaving to their class names to explicit their behavior.
% Minimize lifespan avoiding persistent variables when it is possible.
% Favor the use of collection instead of arrays.
% Interfaces should present a minimal number of parameters, also minimizing the interaction between them.
% Favor ternarization over the use of if-then-else constructs and use a simplified version of the conditionals that implies an early return.
% Moreover, use an early exit logic with continue, break and return instructions.

=======
>>>>>>> 1d166307efed6cc16d1f88322f10d9036b77d4b0
Everything should be formatted in order to make an efficient use of the screen space,
by removing unnecessary tokens (i.e., redundant parentheses, etc.).
Methods should be as short as possible.

\subsection{Syntactic Baggage}
A set of rules are aimed at removing redundant tokens (i.e., brackets,
modifiers, etc.).
\begin{itemize}
  \item Redundant parenthesis and curly brackets.
  \item Removing redundant modifiers:
  \begin{itemize}
    \item \kk{final} in private methods.
    \item \kk{final} from static methods.
    \item \kk{abstract} before interface.
    \item \kk{abstract} before methods in interfaces.
    \item \kk{final} from all methods in final classes.
    \item \kk{private} and \kk{static} from everything defined in anonymous classes.
  \end{itemize}
  \item Removing visibility of all members of an interface
  \item Extra super() calls.
\end{itemize}

\subsection{Shorter phrases}
\begin{itemize}
  \item Distributive rule of booelan expressions
  \item Distributive rule of assignment:
  \begin{code}{JAVA}
a = x;
b = x;
  \end{code}
  becomes
    \begin{code}{JAVA}
a = b = x;
  \end{code}
  \item Distributive rule of arithmetics.
  \item Common prefix of If
  \item Common Suffix of If
  \item Pull out arithmetical negation
  \item Use ternary instead of conditionals.
  \item convert prefix ++ and--into postfix when possibled
  \item Example:
\begin{code}{JAVA}
x.toString()
\end{code}
\begin{code}{JAVA}
"" + x
\end{code}
\end{itemize}

\subsection{Canonical Form of Common Expressions}
Use canonical form for the most common expressions, as much as possibile.
\begin{itemize}
  \item Follow patterns: Pattern: A*x + B
  \item Sorting by size, but also as per the previous rule.
  \item De morgan pushdown logical negation.
  \item Pullup arirthmetic negation.
  \item Pushdown ternarizations. For example:
% \item Example:
  \begin{code}{java}
a ? b(x) : b(y) => b(a ? x: y)
  \end{code}
  \item Apply the distributive rule on booleans. For instance:
% \item Example:
    \begin{code}{JAVA}
a && b || c && b => (a || c) && c
    \end{code}
      This is one variant (there are other three).
  \item More specific first: How should you order X == Y.
        Rule: you start from the more specific and increase specifity,.
        I.e., S(X) > S(Y)
        \begin{enumerate}
          \item null/this/true/false
          \item 0, 1, ""
          \item 12, 13.4
          \item Classes: public, protected, package, private
          \item Fields: Static fields, Fields,
          \item parameters,d
          \item local variables ordered by scope.
          \item ¢
        \end{enumerate}
\end{itemize}

\subsection{Names}
With regards to the naming, Spartan Programming applies three principles:
\begin{itemize}
 \item Generic names policy.
 \item Use short names for return values.
 \item Use short anonymous names.
\end{itemize}
Generally speaking, variable names should be chosen based on their scope.
The shorter the scope the shorter the variable name.
<<<<<<< HEAD
Minimizing variability using \kk{final} and \kk{@NonNull} annotation.
% Stress the use of generic names technique.
% Scope plays a rule:
% in short scopes use short names.
=======
Minimizing variability using \kk{final} and \kk{@NonNull} annotation. 
>>>>>>> 1d166307efed6cc16d1f88322f10d9036b77d4b0
Some (suggested) common names might be:
\begin{enumerate}
  \item \$ for the return variable.
% \item \_\_ don't use.
  \item ¢ penny for the sent argument.
\end{enumerate}
¢ is is in place of "that" (that is a ‟placeholder” like this) or for "sent" argument.
†{The term and symbol of "Penny" is chosen to convey the meaning that is something so little you do not want to worry about.
\emph{Take a penny, leave a penny!}}
Brevity for the sake of brevity is \textbf{not} a prescription in Spartan programming.
It is worth to say that descriptiveness of variable is still a cornerstone principle.
At the same time, Spartan Programming emphasize the need to chose short names, whenever is possible.
In other word, one word name is better than a multi-word name.

Other prescriptions are the following:
\begin{itemize}
 \item Use one letter abbreviations.
 \item Also, use ‟x”
 \item In case of word amalgams, namely multi-words names, take last word.
   Don't use acronyms.

 \item Use plurals with ‟s” (for example for collections).

 \item Do not use unpronounceable names.
 \item Do not use acronyms, unless they are well established (i.e., ASCII, LAN,
   etc.)

 \item Do not include type (i.e., Integer, Boolean, etc.) or the kind (i.e.,
   public, private, etc.) into the names.

\end{itemize}

Variable name might be also a design guideline. If a developers chose a
multi-word variable name for an entity, maybe is try to collapse on that entity
multiple functionalities.  There might be the case to re-think the design,
splitting the entity according to the different functionalityies

\subsection{Variable Elimination}

Spartan programming promote a coding style that do not use many variables,
meaning that it strives to inline instructions instead of storing their results
on variables. The spartanized version of a code not originally written in the
Spartan way, would probably see many of the included variable deleted whenever
and wherever it is possible.

The idea behind this approach is to reduce the cognitive burden of the
developers, either in case of whom is coding who has to spent time and effort
in finding effective names, either in the case of a reader who need to put some
effort to figure out what is the meaning of a variable, starting from its name.

Since variables change, it needs to be sure that it happens when it is supposed
to do. Moreover it is needed to associate a role to a variables, so that the
code that reads that variable can understand and appreciate it and figure out
the list of location where it may be read (CHANGE).

These are some technique for variable elimination.

\subsubsection{Variable Inlining}

The following is a self explanatory example of inlining:

\begin{code}{JAVA}
double a = p.area();
return a;
\end{code}

becomes

\begin{code}{JAVA}
return p.area();
\end{code}

\subsubsection{Early returns}

Another technique for variable elimination is the early return and it consist
in returning the result of a computation as soon as it is available, instead of
storing it in a variable (and then returning it).  An example of early return
is reported in the following code.

\begin{code}{JAVA}
private boolean isKeyword(String token, String[] keywords) {££
    for (int i = 0; i < keywords.length; i++)d
        if (token.equals(keywords[i]))
            return true;
    return false;
}
\end{code}

Using \kk{forech} construct available in several langues it is possible to
avoid the index (in those case in which there are no instructions to access to
it).
\begin{code}{JAVA}
private boolean isKeyword(String token, String[] keywords) {££
    for (final String element : keywords)
        if (element.equals(token))
            return true;
    return false;
}
\end{code}
The same result can be obtained using the some construct to loop over collections,
preferred instead of the arrays, without the use of the \kk{Itarator} class, as
in the previous versions of Java.

% With the early return it becomes:
% \begin{code}{JAVA}
% private ResultRenderer getRenderer() throws InstantiationException,
% IllegalAccessException, ClassNotFoundException {££
% returnᵣesultRenderer != null ? (ResultRenderer)
% Class.forName(ᵣesultRenderer).newInstance() : DefaultResultRenderer();
% }
% \end{code}

% rationale behind the Spartan programming's desire to eliminate variables is that every variable places a burden on both the reader and the writer.
% Each variable has a name. The code writer must spend precious mental effort on picking a good name for the variable. The code reader must spend similar
% effort in figuring out the intention of the reader from the name.
% Variables tend to change. The code writer must invest resources in making sure that the variable is changed only when it is supposed to. The code reader must
% work out the set of locations that may change the variable, and understand the nature of these changes.
% Variables may be used by the code. The code writer must define a role for that variable which suggests where that variable may be read. The code reader must
% understand that role, and to properly appreciate that role, he must work out the list of code locations in which the variable may be read.

\subsubsection{Control simplification}
Spartan programming foster the use of the ternary operator over the \kk{if-else} construct.
This way the implementation of the factorial
\begin{code}{JAVA}
int factorial(int n) {d
    if (n <= 1)
        return n;
    else
        return n * fact(n - 1);
}
\end{code}
becomes
\begin{code}{JAVA}
int factorial(int n) {££
  return n <= 1 ££? n : n * fact(n - 1);
}
\end{code}

in this case in a return statement that allows inlining of the instruction.

\subsubsection{String simplification Techniques}
\begin{itemize}
 \item String transformations
 \item instead of \cc{££.toString()} use \cc{"" +}
 \item x.equals(“a”) -> “a”.equals(b)
 \item Auto insert “”
\end{itemize}

\subsection{Miscellaneous Techniques}

Here we report a series of techniques that not fall expressly in one of the
previous category.

\begin{itemize}
\item Favor prefix operators over postfix ones.
\item In expressions order the operator according to their length (shortest
  come first) or specificity (more specific come first).

\item Associative rule of ifs:
  \begin{code}{JAVA}
if (a) if (b) x;
\end{code}
  \begin{code}{JAVA}
if (a && b) x
  \end{code}
% \item Associative rule of ifs: if (a)
% \begin{code}{JAVA}if (b) x;\end{code}
% \begin{code}{JAVA}if (a && b) x\end{code}
\begin{code}{JAVA}
if (this == null) return super();
\end{code}

\end{itemize}

% \begin{itemize}
% INLINING??
\begin{itemize}
  \item Off load exceptional cases quickly.
  \item inline single use of variables.
  \item Inline multiple use of variables: if 1) result is shorter and 2
) the expression has no side effects.
  \item Pseudo inlining with initializers.
  \item Scope:
\end{itemize}
% \begin{itemize}
% \item Off load exceptional cases quickly.
% \item inline single use of variables.
% \item Inline multiple use of variables: if 1) result is shorter and 2) the expression has no side effects.
% \item Pseudo inlining with initializers.
% \item Scope:
\begin{itemize}
 \item Move into for
 \item Move into try
 \item Move next to use
\end{itemize}
\begin{itemize}
\item Variability (add final when possible.)
\item Variables (inlining)
\item What’s first
\end{itemize}
\begin{itemize}
 \item Most external escape
 \item Shortest: 2*112*a*ab
 \item Least specific
\end{itemize}
\begin{itemize}
  \item Simplificatons
  \begin{itemize}
    \item Algebraic simplifications
    \item Logical simplification
    \item Literal simplification
    \item Arithmetical simplification
  \end{itemize}
  \item Patterns: 2 * x + 1d
  \item Pushdown:
   \item Logical Negation
  \item Arithmetical Negation
  \item Auto distributive
  \item Repeated deterministic expressions
  \item Auto
  \begin{itemize}
    \item Auto Collect
    \item Auto insert/remove 0+ in ternarization.
    \item Auto insert/remove 1*
    \item Auto add “” +
  \end{itemize}
\end{itemize}
\begin{itemize}

\subsection{Renaming}
\begin{itemize}
  \item In constructors: Arguments to corresponding field names
  \item In fields: to canonical instance name or pluralized
  \item In getters: Change name to fieldName if it is a getter.
  \item In Methods
  \item In local variables:
  \item return variable to \$
\end{itemize}
\item Change argument to one single case letter
% \item In world amalgams, use the first letter of the last word.
% \item Multiplicities
\begin{itemize}
  \item Deal with multiplicities of arrays
  \item Deal with multiplicities of collections
  \item Deal with nested multiplicities
\end{itemize}
\item Change return type of void to ClassName and return this
\begin{itemize}
  \item Single argument:
  \begin{itemize}
    \item To \_\_ if unused
    \item To \$ in case it is returned
    \item To fieldName in case it is a setter
    \item To ¢ in case method has no inner methods and is not a setter
   \end{itemize}
  \begin{itemize}
    \item Any number of arguments:
    \item To \$ in case it is returned
    \item To \cc{\_\_}
      if it is unused and documented as such
   \end{itemize}
  % \item Change argument to one single case letter
  % \item In world amalgams, use the first letter of the last word.
  \item Deal with multiplicities
\end{itemize}
\end{itemize}

% \begin{itemize}
% \item \item Ternarize
% \item Early return
% \item Example:
% \begin{code}{JAVA}
% @SuppressWarnings("unused") private
% void earlyReturn(int a) {££
% if (new Random().nextInt() <= 3) {££
% earlyReturn(12);
% earlyReturn(124);
% } else {££
% earlyReturn(4);
% earlyReturn(5);
% earlyReturn(44);
% }
% }
% \end{code}
% \end{itemize}
