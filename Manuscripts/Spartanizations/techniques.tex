\subsection{Syntactic Baggage}
A set of rules are aimed at removing redundant tokens (i.e., brackets,
modifiers, etc.).
\begin{itemize}
  \item Redundant parenthesis and curly brackets.
  \item Removing redundant modifiers:
        \begin{itemize}
          \item \kk{final} in private methods.
          \item \kk{final} from static methods.
          \item \kk{abstract} before interface.
          \item \kk{abstract} before methods in interfaces.
          \item \kk{final} from all methods in final classes.
          \item \kk{private} and \kk{static} from everything defined in
                anonymous classes.
        \end{itemize}
  \item Removing visibility of all members of an interface
  \item Extra super() calls.
\end{itemize}

\subsection{Shorter phrases}
\begin{itemize}
  \item Distributive rule of Boolean expressions
  \item Distributive rule of assignment:
        \begin{code}{JAVA}
a = x;
b = x;
  \end{code}
  becomes
  \begin{code}{JAVA}
a = b = x;
  \end{code}
  \item Distributive rule of arithmetic.
  \item Common prefix of If
  \item Common Suffix of If
  \item Pull out arithmetical negation
  \item Use ternary instead of conditionals.
  \item convert prefix ++ and--into postfix when possible
  \item Example:
        \begin{code}{JAVA}
x.toString()
  \end{code}
  \begin{code}{JAVA}
"" + x
  \end{code}
\end{itemize}

\subsection{Canonical Form of Common Expressions}
Use canonical form for the most common expressions, as much as possibile.
\begin{itemize}
  \item Follow patterns: Pattern: A*x + B
  \item Sorting by size, but also as per the previous rule.
  \item De Morgan pushdown logical negation.
  \item Pullup arirthmetic negation.
  \item Pushdown ternarizations. For example:
        % \item Example:
        \begin{code}{java}
a ££? b(x) : b(y) => b(a ££? x: y)
  \end{code}
  \item Apply the distributive rule on booleans. For instance:
        % \item Example:
        \begin{code}{JAVA}
a && b || c && b => (a || c) && c
  \end{code}
  This is one variant (there are other three).
  \item More specific first: How should you order X == Y.
        Rule: you start from the more specific and increase specifity, i.e.,
        S(X) > S(Y)
        \begin{enumerate}
          \item null/this/true/false
          \item 0, 1, ""
          \item 12, 13.4
          \item Classes: public, protected, package, private
          \item Fields: Static fields, Fields,
          \item parameters,d
          \item local variables ordered by scope.
          \item ¢
        \end{enumerate}
\end{itemize}

\subsection{Names}
With regards to the naming, Spartan Programming applies three principles:
\begin{itemize}
  \item Generic names policy.
  \item Use short names for return values.
  \item Use short anonymous names.
\end{itemize}
Generally speaking, variable names should be chosen based on their scope.
The shorter the scope the shorter the variable name.
Minimizing variability using \kk{final} and \kk{@NonNull} annotation.
% Stress the use of generic names technique.
% Scope plays a rule:
% in short scopes use short names.
Some (suggested) common names might be:
\begin{enumerate}
  \item \$ for the return variable.
        % \item \_\_ don't use.
  \item ¢ penny for the sent argument.
\end{enumerate}
¢ is is in place of "that" (that is a ‟placeholder” like this) or for ``sent''
argument.†{The term and symbol of "Penny" is chosen to convey the meaning
  that is something so little you do not want to worry about.
  \emph{Take a penny, leave a penny!}}

Brevity for the sake of brevity is \textbf{not} a prescription in Spartan
programming.  It is worth to say that descriptiveness of variable is still a
cornerstone principle.  At the same time, Spartan Programming emphasize the
need to chose short names, whenever is possible.  In other word, one word name
is better than a multi-word name.

Other prescriptions are the following:
\begin{itemize}
  \item Use one letter abbreviations.
  \item Also, use ‟x”
  \item In case of word amalgams, namely multi-words names, take last word.
        Don't use acronyms.

  \item Use plurals with ‟s” (for example for collections).

  \item Do not use unpronounceable names.
  \item Do not use acronyms, unless they are well established (i.e., ASCII,
        LAN, etc.)

  \item Do not include type (i.e., Integer, Boolean, etc.) or the kind (i.e.,
        public, private, etc.) into the names.

\end{itemize}

Variable name might be also a design guideline. If a developers chose a
multi-word variable name for an entity, maybe is try to collapse on that entity
multiple functionalities.  There might be the case to re-think the design,
splitting the entity according to the different functionalities

\subsection{Variable Elimination}

Spartan programming promote a coding style that do not use many variables,
meaning that it strives to inline instructions instead of storing their results
on variables. The spartanized version of a code not originally written in the
Spartan way, would probably see many of the included variable deleted whenever
and wherever it is possible.

The idea behind this approach is to reduce the cognitive burden of the
developers, either in case of whom is coding who has to spent time and effort
in finding effective names, either in the case of a reader who need to put some
effort to figure out what is the meaning of a variable, starting from its name.

Since variables change, it needs to be sure that it happens when it is supposed
to do. Moreover it is needed to associate a role to a variables, so that the
code that reads that variable can understand and appreciate it and figure out
the list of location where it may be read (CHANGE).

These are some technique for variable elimination.

\subsubsection{Variable Inlining}

The following is a self explanatory example of inlining:

\begin{code}{JAVA}
double a = p.area();
return a;
\end{code}

becomes

\begin{code}{JAVA}
return p.area();
\end{code}

\subsubsection{Early returns}

Another technique for variable elimination is the early return and it consist
in returning the result of a computation as soon as it is available, instead of
storing it in a variable (and then returning it).  An example of early return
is reported in the following code.

\begin{code}{JAVA}
private boolean isKeyword(String token, String[] keywords) {££
    for (int i = 0; i < keywords.length; i++)d
        if (token.equals(keywords[i]))
            return true;
    return false;
}
\end{code}

Using \kk{forech} construct available in several langues it is possible to
avoid the index (in those case in which there are no instructions to access to
it).
\begin{code}{JAVA}
private boolean isKeyword(String token, String[] keywords) {££
    for (final String element : keywords)
        if (element.equals(token))
            return true;
    return false;
}
\end{code}
The same result can be obtained using the some construct to loop over
collections, preferred instead of the arrays, without the use of the
\cc{Iterator} class, as in the previous versions of Java.

% With the early return it becomes:
% \begin{code}{JAVA}
% private ResultRenderer getRenderer() throws InstantiationException,
% IllegalAccessException, ClassNotFoundException {££
% returnᵣesultRenderer != null ? (ResultRenderer)
% Class.forName(ᵣesultRenderer).newInstance() : DefaultResultRenderer();
% }
% \end{code}

\subsubsection{Control simplification}
Spartan programming foster the use of the ternary operator over the
\kk{if-else} construct.  This way the implementation of the factorial
\begin{code}{JAVA}
int factorial(int n) {d
    if (n <= 1)
        return n;
    else
        return n * fact(n - 1);
}
\end{code}
becomes
\begin{code}{JAVA}
int factorial(int n) {££
  return n <= 1 ££? n : n * fact(n - 1);
}
\end{code}
in this case in a return statement that allows inlining of the instruction.

\subsubsection{String simplification Techniques}
\begin{itemize}
  \item String transformations
  \item instead of \cc{££.toString()} use \cc{"" +}
  \item x.equals(“a”) -> “a”.equals(b)
  \item Auto insert “”
\end{itemize}

\subsection{Miscellaneous Techniques}

Here we report a series of techniques that not fall expressly in one of the
previous category.

\begin{itemize}
  \item Favor prefix operators over postfix ones.
  \item In expressions order the operator according to their length (shortest
        come first) or specificity (more specific come first).
  \item Associative rule of ifs:
        \begin{code}{JAVA}
if (a) if (b) x;
  \end{code}
  \begin{code}{JAVA}
if (a && b) x
  \end{code}
  % \item Associative rule of ifs: if (a)
  % \begin{code}{JAVA}if (b) x;\end{code}
  % \begin{code}{JAVA}if (a && b) x\end{code}
  \begin{code}{JAVA}
if (this == null) return super();
  \end{code}


  INLINING??
  \begin{itemize}
    \item Off load exceptional cases quickly.
    \item inline single use of variables.
    \item Inline multiple use of variables: if 1) result is shorter and 2
          ) the expression has no side effects.
    \item Pseudo inlining with initializers.
    \item Scope:
  \end{itemize}

  Scope:
  \begin{itemize}
    \item Move into for
    \item Move into try
    \item Move next to use
  \end{itemize}
  Variability
  \begin{itemize}
    \item Variability (add final when possible.)
    \item Variables (inlining)
    \item What’s first
  \end{itemize}
  Sorting
  \begin{itemize}
    \item Most external escape
    \item Shortest: 2*112*a*ab
    \item Least specific
  \end{itemize}
  Canonical ordering
  \begin{itemize}
    \item Simplificatons
          \begin{itemize}
            \item Algebraic simplifications
            \item Logical simplification
            \item Literal simplification
            \item Arithmetical simplification
          \end{itemize}
    \item Patterns: 2 * x + 1d
    \item Pushdown:
    \item Logical Negation
    \item Arithmetical Negation
    \item Auto distributive
    \item Repeated deterministic expressions
    \item Auto
          \begin{itemize}
            \item Auto Collect
            \item Auto insert/remove 0+ in ternarization.
            \item Auto insert/remove 1*
            \item Auto add “” +
          \end{itemize}
  \end{itemize}

  \subsection{Renaming}
  \begin{itemize}
    \item In constructors: Arguments to corresponding field names
    \item In fields: to canonical instance name or pluralized
    \item In getters: Change name to fieldName if it is a getter.
    \item In Methods
    \item In local variables:
    \item return variable to \$
  \end{itemize}
  \item Change argument to one single case letter
        % \item In world amalgams, use the first letter of the last word.
        % \item Multiplicities
        \begin{itemize}
          \item Deal with multiplicities of arrays
          \item Deal with multiplicities of collections
          \item Deal with nested multiplicities
        \end{itemize}
  \item Change return type of void to ClassName and return this
        \begin{itemize}
          \item Single argument:
                \begin{itemize}
                  \item To \_\_ if unused
                  \item To \$ in case it is returned
                  \item To fieldName in case it is a setter
                  \item To ¢ in case method has no inner methods and is not a
                        setter
                \end{itemize}
                \begin{itemize}
                  \item Any number of arguments:
                  \item To \$ in case it is returned
                  \item To \cc{\_\_}
                        if it is unused and documented as such
                \end{itemize}
                % \item Change argument to one single case letter
                % \item In world amalgams, use the first letter of the last word.
          \item Deal with multiplicities
        \end{itemize}
\end{itemize}

% \begin{itemize}
% \item \item Ternarize
% \item Early return
% \item Example:
% \begin{code}{JAVA}
% @SuppressWarnings("unused") private
% void earlyReturn(int a) {££
% if (new Random().nextInt() <= 3) {££
% earlyReturn(12);
% earlyReturn(124);
% } else {££
% earlyReturn(4);
% earlyReturn(5);
% earlyReturn(44);
% }
% }
% \end{code}
% \end{itemize}
\begin{figure}
  \caption{An automatically spartanized version of
      the \Java program of \cref{figure:eclipse}}
    \label{figure:eclipse:automatic}
    \begin{adjustbox}{max width=\columnwidth}
\begin{code}[minipage, width=1.20\columnwidth]{JAVA}
public class Test1 { // comments and £\kk{import}£ directives omitted for brevity
  public static void main(final String args[]) {££
    final ASTParser p = ASTParser.newParser(AST.JLS3);
    p.setSource((
      "public class A {\n" +
      " int i = 9;\n"+ //
      " int j;\n" + //
      " ArrayList<Integer> al = new ArrayList<Integer>();\n" + //
      " j=1000;\n" + // sic!
      "}\n").toCharArray());
    final CompilationUnit u = (CompilationUnit) p.createAST(null);
    u.accept(new ASTVisitor() {££
      Set £\ignore$£$ = new HashSet();
      @Override public boolean visit(final SimpleName ¢) {££
        if (£\ignore$£$.contains(¢.getIdentifier()))
          System.out.println("Usage of '" + ¢ + //
            "' at line " + u.getLineNumber(¢.getStartPosition()));
        return true;
      }
      @Override public boolean visit(final VariableDeclarationFragment f) {££
        final SimpleName ¢ = f.getName();
        £\ignore$£$.add(¢.getIdentifier());
        System.out.println("Declaration of '" + ¢ + //
          "' at line" + u.getLineNumber(¢.getStartPosition()));
        return false; // do not continue to avoid usage info
      }
    });
  }
}
\end{code}
  \end{adjustbox}
\end{figure}

Each of the several wrings applied to obtain \cref{figure:eclipse:automatic}
  reduced at least one of our minimization ends.
At several occasions, cleanup increased these.
Overall, in this case, the result of automatic application of spartanization
  is a reduction in the number of lines, words, and characters
  by factors of~$1.6$,~$1.18$, and~$1.4$.\footnote{Part of this improvement
  is due to cleanup, optimization the use of \kk{import}; we shall account
for this phenomena in the empirical section.} 

\Cref{figure:eclipse:spartan} shows the spartanized version of the program in
the \cref{figure:eclipse}. Employed were nominal spartanization, e.g., renaming
variable \cc{names} to~\cc{\$}, structural spartanization, e.g., for the
removal of braces, and modularization.

The product of external cleanup, which in this case amounts to adding
\kk{final}s and \kk{@Override}, is not included in this example.

The main difference between the figures is due to method extractions, conducted
manually. Function \cc{go()} minimizes exploitation of scope by denying
access to the \cc{args} argument of function \cc{main}.
Function \cc{makeCompilationUnit()} takes advantage of the fact that variable
\cc{parser} is only used in a limited section of \cc{main}, etc.

Examining the body of the anonymous class (that one that \cc{extends} \cc{ASTVisitor})
we see some more extracted methods. The reduction in clutter due to
spartanization makes it possible to identify another spot of useful method
extraction.

\begin{figure}
  \caption{Spartanized version including structural, nominal, modular, but
    not cleanups, of the \Java program in \cref{figure:eclipse}.}
  \label{figure:eclipse:spartan}
  \begin{adjustbox}{max width = \columnwidth}
\begin{code}[minipage, width=1.13\columnwidth]{JAVA}
public class Test { // comments and £\kk{import}£ directives omitted for brevity
  public static void main(String args[]) { go(); }
  private static void go() {££
    CompilationUnit u = makeCompilationUnit();
    u.accept(new ASTVisitor() {££
      Set £\ignore$£$ = new HashSet();
      public boolean visit(SimpleName ¢) {££
        note(¢);
        return true;
      }
      public boolean visit(VariableDeclarationFragment ¢) {££
        collect(¢.getName());
        return false;
      }
      void note(SimpleName ¢) {££
        if (£\ignore$£$.contains(¢.getIdentifier()))
          System.out.println("Usage of '" + ¢ + //
            "' at line " + u.getLineNumber(¢.getStartPosition()));
      }
      void collect(SimpleName ¢) {££
        £\ignore$£$.add(¢.getIdentifier());
        System.out.println("Declaration of '" + ¢ + //
          "' at line" + u.getLineNumber(¢.getStartPosition()));
      }
    });
  }
  private static CompilationUnit makeCompilationUnit() {££
    return (CompilationUnit) makeParser().createAST(null);
  }
  private static ASTParser makeParser() {££
    ASTParser £\ignore$£$ = ASTParser.newParser(AST.JLS3);
    £\ignore$£$.setSource(
      "public class A {\n" +
      " int i = 9;\n"+ //
      " int j;\n" + //
      " ArrayList<Integer> al = new ArrayList<Integer>();\n" + //
      " j=1000;\n" + // sic!
      "}\n" + //
      .toCharArray()
);
    £\ignore$£$.setKind(ASTParser.K£\_£COMPILATION£\_£UNIT);
    return £\ignore$£$;
  }
}
\end{code}
  \end{adjustbox}
\end{figure}

% Yet another, further simplified version of the code of \cref{figure:eclipse} shows
% up in \cref{figure:eclipse:extract}. This figure depicts only the anonymous
% class found in previous figures, but with extra method extracted to simplify
% the code. Of course, a demand for clever method extraction can not be part of a
% strucured We argue that the
% process of spartanization helped in
% this case to highlight

\label{section:automation}
% However, being in a certain sense, counter intuitive, in order to apply
% Spartanization on their working routines, the developers need to respect a firm
% discipline. From a certain standpoint, Spartan Programming might be seen as a
% list of code style prescription, but it would just scratch the surface. It is
% far more than that, since it
%
% Being minimized, spartanized code might be less readable that the original.
% This is … Spartan programming is not directly concerned with readability, at
% least not in its subjective and cultural-dependent sense. In fact, spartan
% programs will bring much misery to anyone preferring long, verbose programs.
%
% Spartan programming prescribes, a careful use of the variables, stressing the need
% to inline variables that are used only once and emphasizing the use of foreach loops
% in languages implementing it. Variables visibility and accessibility should also be
% possibly minimized, favoring the use of private over public variables whenever it
% is possible.
%
% Also the names of variables should be taken short for local variables, with
% short scope, leaving to their class names to explicit their behavior.
% Minimizing variability using final and @NonNull annotation. Stress the use of
% generic names technique. Minimize lifespan avoiding persistent variables when
% it is possible. Favor the use of collection instead of arrays. Interfaces
% should present a minimal number of parameters, also minimizing the interaction
% between them. Favor ternarization over the use of if-then-else constructs and
% use a simplified version of the conditionals that implies an early return.
% Moreover, use an early exit logic with continue, break and return instructions.
%
% Everything should be formatted in order to make an efficient use of the screen
% space, by removing unnecessary tokens (i.e., redundant parentheses, etc.).
% Methods should be as short as possible.
