Spartanization aims at minimizing:
\begin{itemize}
 \item Vertical complexity: the number of lines of code.
 \item Horizontal complexity.
 \item Characters, tokens, parameters and variable.
 \item Loops.
 \item Conditional statements.
\end{itemize}

Spartan programming prescribes, a careful use of the variables, stressing the need
to inline variables that are used only once and emphasizing the use of foreach loops
in languages implementing it. Variables visibility and accessibility should also be
possibly minimized, favoring the use of private over public variables whenever it
is possible.

Also the names of variables should be taken short for local variables, with short scope,
leaving to their class names to explicit their behavior. Minimizing variability using
final and @NonNull annotation. Stress the use of generic names technique. Minimize lifespan
avoiding persistent variables when it is possible. Favor the use of collection instead
of arrays. Interfaces should present a minimal number of parameters, also minimizing
the interaction between them. Favor ternarization over the use of if-then-else constructs
and use a simplified version of the conditionals that implies an early return. Moreover,
use an early exit logic with continue, break and return instructions.

Everything should be formatted in order to make an efficient use of the screen space,
by removing unnecessary tokens (i.e., redundant parentheses, etc.).
Methods should be as short as possible.

\subsection{Syntactic Baggage}
A set of rules are aimed at removing redundants tokens (i.e. brackets, modifiers, etc.).
\begin{itemize}
  \item Redundant parenthesis and curly brackets.
  \item Removing redundant modifiers:
  \begin{itemize}
    \item \kk{final} in private methods.
    \item \kk{final} from static methods.
    \item \kk{abstract} before interface.
    \item \kk{abstract} before methods in interfaces.
    \item \kk{final} from all methods in final classes.
    \item \kk{private} and \kk{static} from everything defined in anonymous classes.
  \end{itemize}
  \item Removing visibility of all members of an interface
  \item Extra super() calls.
\end{itemize}

\subsection{Shorter phrases}
\begin{itemize}
  \item Distributive rule of booelan expressions
  \item Distributive rule of assignment: 
  \begin{code}{JAVA}
a = x; 
b = x;   
  \end{code}
  becomes
    \begin{code}{JAVA}
a = b = x;   
  \end{code}
  \item Distributive rule of arithmetics.
  \item Common prefix of If
  \item Common Suffix of If
  \item Pull out arithmetical negation
  \item Use ternary instead of conditionals.
  \item convert prefix ++ and--into postfix when possible
  \item Example:
\begin{code}{JAVA}
x.toString()
\end{code}
\begin{code}{JAVA}
"" + x
\end{code}
\end{itemize}

\subsection{Canonical Form of Common Expressions}
Use canonical form for the most common expressions, as much as possibile.
\begin{itemize}
  \item Follow patterns: Pattern: A*x + B
  \item Sorting by size, but also as per the previous rule.
  \item De morgan pushdown logical negation.
  \item Pullup arirthmetic negation.
  \item Pushdown ternarizations. For example:
%   \item Example:
  \begin{code}{java}
a ? b(x) : b(y) => b(a ? x: y)
  \end{code}
  \item Apply the distributive rule on booleans. For instance:
%   \item Example:
    \begin{code}{JAVA}
a && b || c && b => (a || c) && c
    \end{code}
      This is one variant (there are other three).
  \item More specific first: How should you order X == Y.
        Rule: you start from the more specific and increase specifity,.
        I.e., S(X) > S(Y)
        \begin{enumerate}
          \item null/this/true/false
          \item 0, 1, ""
          \item 12, 13.4
          \item Classes: public, protected, package, private
          \item Fields: Static fields, Fields,
          \item parameters,
          \item local variables ordered by scope.
          \item ¢
        \end{enumerate}
\end{itemize}

\subsection{Names}
With regards to the naming, Spartan Programming applies three principles:
\begin{itemize}
 \item Generic names policy.
 \item Use short names for return values.
 \item Use short anonymous names.
\end{itemize}
Generally speaking, variable names should be chosen based on their scope.
The shorter the scope the shorter the variable name.
% Scope plays a rule:
% in short scopes use short names.
Some (suggested) common names might be:
\begin{enumerate}
  \item \$ for the return variable.
%   \item \_\_ don't use.
  \item ¢ penny for the sent argument.
\end{enumerate}
¢ is is in place of "that" (that is a ``placeholder'' like this) or for "sent" argument.
\footnote{The term and symbol of "Penny" is chosen to convey the meaning that is something so little you do not want to worry about.
\emph{Take a penny, leave a penny!}}
Brevity for the sake of brevity is \textbf{not} a prescription in Spartan programming. 
It is worth to say that descriptiveness of variable is still a cornerstone principle. 
At the same time, Spartan Programming emphasize the need to chose short names, whenever is possible.
In other word, one word name is better than a multi-word name.

Other prescriptions are the following:
\begin{itemize}
 \item Use one letter abbreviations.
 \item Also, use ‟x”
 \item Take last word, don't use acronyms.
 \item Use plurals with 's'
 \item Do not use unpronouncable names.
 \item Do not use acronyms, unless they are well established (i.e. ASCII, LAN, etc.)
 \item Do not include type (i.e. Integer, Boolean, etc.) or the kind (i.e. public, private, etc.) into the names.
\end{itemize}

Variable name might be also a design guideline. If a developers chose a multi-word variable name for an 
entity, maybe is try to collapse on that entity multiple functionalities. 
There might be the case to re-think the design, splitting the entity according to the different functionalityies 

% Like the "it" variable in ML programming language or HyperCard programming language on macintosh. Ancient!!!


\subsection{Misc}
\begin{itemize}
\item Prefix to postifx
x.equals("a:) to "a.equals(this" (???)


\item Associative rule of ifs: 
  \begin{code}{JAVA}
if (a) if (b) x;
\end{code}
  \begin{code}{JAVA}
if (a && b) x
  \end{code}
% \item Associative rule of ifs: if (a) 
% \begin{code}{JAVA}if (b) x;\end{code}
% \begin{code}{JAVA}if (a && b) x\end{code}
\begin{code}{JAVA}
if (this == null) return super();
????\end{code}
  
  \end{itemize}

\subsection{Early returns and the such}
\begin{itemize}
\item Off load exceptional cases quickly.
\item inline single use of variables.
\item Inline multiple use of variables: if 1) result is shorter and 2) the expression has no side effects.
\item Pseudo inlining with initializers.
\item Scope:
\begin{itemize}
 \item Move into for
 \item Move into try
 \item Move next to use
\end{itemize}
\item Variability (add final when possible.)
\item Variables (inlining)
\item What’s first
\begin{itemize}
 \item Most external escape
 \item Shortest: 2*112*a*ab
 \item Least specific
\end{itemize}
\item Simplificatons
\begin{itemize}
 \item Algebraic simplifications
 \item Logical simplification
 \item Literal simplification
 \item Arithmetical simplification
\end{itemize}
\item String simplification
\begin{itemize}
 \item String transformations
 \item .toString() -> “” +
 \item x.equals(“a”) -> “a”.equals(b)
 \item Auto insert “”
\end{itemize}
\item Patterns: 2 * x + 1
\item Pushdown:
\item Logical Negation
\item Arithmetical Negation
\item Auto distributive
\item Repeated deterministic expressions
\item Auto
\begin{itemize}
 \item Auto Collect
 \item Auto insert/remove 0+ in ternarization.
 \item Auto insert/remove 1*
 \item Auto add “” +
\end{itemize}

\item Control simplification
\begin{itemize}
 \item \item Ternarize
\item Early return
\item Example: 
\begin{code}{JAVA}
@SuppressWarnings("unused") private
void earlyReturn(int a) {
  if (new Random().nextInt() <= 3) {
    earlyReturn(12);
    earlyReturn(124);
    } else {
    earlyReturn(4);
    earlyReturn(5);
    earlyReturn(44);
  }
}
\end{code}
\end{itemize}
\end{itemize}

\begin{itemize}
\item Switch Normalization
\item Renamings:
\begin{itemize}
 \item In constructors: Arguments to corresponding field names
 \item In fields: to canonical instance name or pluralized
 \item In getters: Change name to fieldName if it is a getter.
 \item In Methods
\end{itemize}

\item In local variables:
\item return variable to \$
\item Change argument to one single case letter
\item In world amalgams, use the first letter of the last word.
\item Deal with multiplicities of arrays
\item Deal with multiplicities of collections
\item Deal with nested multiplicities
\item Change return type of void to ClassName and return this
\item Single argument:
\item To \_\_ if unused
\item To \$ in case it is returned
\item To fieldName in case it is a setter
\item To ¢ in case method has no inner methods and is not a setter
\item Any number of arguments:
\item To \$ in case it is returned
\item To__(n) if it is unused and documented as such
\item Change argument to one single case letter
\item In world amalgams, use the first letter of the last word.
\item Deal with multiplicities
\end{itemize}

